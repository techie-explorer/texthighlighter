<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>utils/dom.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="IndependenciaHighlighter.html">IndependenciaHighlighter</a><ul class='methods'><li data-type='method'><a href="IndependenciaHighlighter.html#deserializeHighlights">deserializeHighlights</a></li><li data-type='method'><a href="IndependenciaHighlighter.html#doHighlight">doHighlight</a></li><li data-type='method'><a href="IndependenciaHighlighter.html#focusUsingId">focusUsingId</a></li><li data-type='method'><a href="IndependenciaHighlighter.html#getHighlights">getHighlights</a></li><li data-type='method'><a href="IndependenciaHighlighter.html#isHighlight">isHighlight</a></li><li data-type='method'><a href="IndependenciaHighlighter.html#normalizeHighlights">normalizeHighlights</a></li><li data-type='method'><a href="IndependenciaHighlighter.html#removeHighlights">removeHighlights</a></li><li data-type='method'><a href="IndependenciaHighlighter.html#serializeHighlights">serializeHighlights</a></li></ul></li><li><a href="PrimitivoHighlighter.html">PrimitivoHighlighter</a><ul class='methods'><li data-type='method'><a href="PrimitivoHighlighter.html#deserializeHighlights">deserializeHighlights</a></li><li data-type='method'><a href="PrimitivoHighlighter.html#doHighlight">doHighlight</a></li><li data-type='method'><a href="PrimitivoHighlighter.html#flattenNestedHighlights">flattenNestedHighlights</a></li><li data-type='method'><a href="PrimitivoHighlighter.html#getHighlights">getHighlights</a></li><li data-type='method'><a href="PrimitivoHighlighter.html#highlightRange">highlightRange</a></li><li data-type='method'><a href="PrimitivoHighlighter.html#isHighlight">isHighlight</a></li><li data-type='method'><a href="PrimitivoHighlighter.html#mergeSiblingHighlights">mergeSiblingHighlights</a></li><li data-type='method'><a href="PrimitivoHighlighter.html#normalizeHighlights">normalizeHighlights</a></li><li data-type='method'><a href="PrimitivoHighlighter.html#removeHighlights">removeHighlights</a></li><li data-type='method'><a href="PrimitivoHighlighter.html#serializeHighlights">serializeHighlights</a></li></ul></li><li><a href="TextHighlighter.html">TextHighlighter</a><ul class='methods'><li data-type='method'><a href="TextHighlighter.html#.createWrapper">createWrapper</a></li><li data-type='method'><a href="TextHighlighter.html#deserializeHighlights">deserializeHighlights</a></li><li data-type='method'><a href="TextHighlighter.html#destroy">destroy</a></li><li data-type='method'><a href="TextHighlighter.html#find">find</a></li><li data-type='method'><a href="TextHighlighter.html#focusUsingId">focusUsingId</a></li><li data-type='method'><a href="TextHighlighter.html#getColor">getColor</a></li><li data-type='method'><a href="TextHighlighter.html#getHighlights">getHighlights</a></li><li data-type='method'><a href="TextHighlighter.html#highlightHandler">highlightHandler</a></li><li data-type='method'><a href="TextHighlighter.html#highlightRange">highlightRange</a></li><li data-type='method'><a href="TextHighlighter.html#isHighlight">isHighlight</a></li><li data-type='method'><a href="TextHighlighter.html#normalizeHighlights">normalizeHighlights</a></li><li data-type='method'><a href="TextHighlighter.html#registerDefaultEvents">registerDefaultEvents</a></li><li data-type='method'><a href="TextHighlighter.html#removeHighlights">removeHighlights</a></li><li data-type='method'><a href="TextHighlighter.html#serializeHighlights">serializeHighlights</a></li><li data-type='method'><a href="TextHighlighter.html#setColor">setColor</a></li></ul></li></ul><h3>Externals</h3><ul><li><a href="external-_jQuery.fn_.html">jQuery.fn</a><ul class='methods'><li data-type='method'><a href="external-_jQuery.fn_.html#.textHighlighter">textHighlighter</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#arrayToLower">arrayToLower</a></li><li><a href="global.html#createWrapper">createWrapper</a></li><li><a href="global.html#DATA_ATTR">DATA_ATTR</a></li><li><a href="global.html#dom">dom</a></li><li><a href="global.html#findHigherPriorityHighlights">findHigherPriorityHighlights</a></li><li><a href="global.html#findNodesAndOffsets">findNodesAndOffsets</a></li><li><a href="global.html#getHighlightedTextForRange">getHighlightedTextForRange</a></li><li><a href="global.html#getHighlightedTextRelativeToRoot">getHighlightedTextRelativeToRoot</a></li><li><a href="global.html#getHighlighterNamespace">getHighlighterNamespace</a></li><li><a href="global.html#groupHighlights">groupHighlights</a></li><li><a href="global.html#haveSameColor">haveSameColor</a></li><li><a href="global.html#IGNORE_TAGS">IGNORE_TAGS</a></li><li><a href="global.html#isClosestHighlightParent">isClosestHighlightParent</a></li><li><a href="global.html#isHighestPriority">isHighestPriority</a></li><li><a href="global.html#nodesInBetween">nodesInBetween</a></li><li><a href="global.html#normaliseOffset">normaliseOffset</a></li><li><a href="global.html#normaliseText">normaliseText</a></li><li><a href="global.html#refineRangeBoundaries">refineRangeBoundaries</a></li><li><a href="global.html#scaleFromTransformMatrix">scaleFromTransformMatrix</a></li><li><a href="global.html#sortByDepth">sortByDepth</a></li><li><a href="global.html#TIMESTAMP_ATTR">TIMESTAMP_ATTR</a></li><li><a href="global.html#unique">unique</a></li><li><a href="global.html#validateIndependenciaDescriptors">validateIndependenciaDescriptors</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">utils/dom.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { isElementHighlight } from "./highlights";
import { DATA_ATTR } from "../config";
export const NODE_TYPE = { ELEMENT_NODE: 1, TEXT_NODE: 3, COMMENT_NODE: 8 };

/**
 * Utility functions to make DOM manipulation easier.
 * @param {Node|HTMLElement} [el] - base DOM element to manipulate
 * @returns {object}
 *
 */
const dom = function(el) {
  return /** @lends dom **/ {
    /**
     * Adds class to element.
     * @param {string} className
     */
    addClass: function(className) {
      if (el.classList) {
        el.classList.add(className);
      } else {
        el.className += " " + className;
      }
    },

    /**
     * Removes class from element.
     * @param {string} className
     */
    removeClass: function(className) {
      if (el.classList) {
        el.classList.remove(className);
      } else {
        el.className = el.className.replace(
          new RegExp("(^|\\b)" + className + "(\\b|$)", "gi"),
          " ",
        );
      }
    },

    /**
     * Prepends child nodes to base element.
     * @param {Node[]} nodesToPrepend
     */
    prepend: function(nodesToPrepend) {
      let nodes = Array.prototype.slice.call(nodesToPrepend),
        i = nodes.length;

      while (i--) {
        el.insertBefore(nodes[i], el.firstChild);
      }
    },

    /**
     * Appends child nodes to base element.
     * @param {Node[]} nodesToAppend
     */
    append: function(nodesToAppend) {
      let nodes = Array.prototype.slice.call(nodesToAppend);

      for (let i = 0, len = nodes.length; i &lt; len; ++i) {
        el.appendChild(nodes[i]);
      }
    },

    /**
     * Inserts base element after refEl.
     * @param {Node} refEl - node after which base element will be inserted
     * @returns {Node} - inserted element
     */
    insertAfter: function(refEl) {
      return refEl.parentNode.insertBefore(el, refEl.nextSibling);
    },

    /**
     * Inserts base element before refEl.
     * @param {Node} refEl - node before which base element will be inserted
     * @returns {Node} - inserted element
     */
    insertBefore: function(refEl) {
      return refEl.parentNode.insertBefore(el, refEl);
    },

    /**
     * Removes base element from DOM.
     */
    remove: function() {
      el.parentNode.removeChild(el);
      el = null;
    },

    /**
     * Returns true if base element contains given child.
     * @param {Node|HTMLElement} child
     * @returns {boolean}
     */
    contains: function(child) {
      return el !== child &amp;&amp; el.contains(child);
    },

    /**
     * Wraps base element in wrapper element.
     * @param {HTMLElement} wrapper
     * @returns {HTMLElement} wrapper element
     */
    wrap: function(wrapper) {
      if (el.parentNode) {
        el.parentNode.insertBefore(wrapper, el);
      }

      wrapper.appendChild(el);
      return wrapper;
    },

    /**
     * Unwraps base element.
     * @returns {Node[]} - child nodes of unwrapped element.
     */
    unwrap: function() {
      let nodes = Array.prototype.slice.call(el.childNodes),
        wrapper;

      nodes.forEach(function(node) {
        wrapper = node.parentNode;
        dom(node).insertBefore(node.parentNode);
      });
      dom(wrapper).remove();

      return nodes;
    },

    /**
     * Returns array of base element parents.
     * @returns {HTMLElement[]}
     */
    parents: function() {
      let parent,
        path = [];

      while ((parent = el.parentNode)) {
        path.push(parent);
        el = parent;
      }

      return path;
    },

    /**
     * Returns array of base element parents up to the
     * provided root element.
     *
     * @param {HTMLElement} rootElement
     * @returns {HTMLElement[]}
     */
    parentsUpTo: function(rootElement) {
      let parent,
        path = [];

      while ((parent = el.parentNode) &amp;&amp; parent !== rootElement) {
        path.push(parent);
        el = parent;
      }

      return path;
    },

    /**
     * Returns array of base element parents, excluding the document.
     * @returns {HTMLElement[]}
     */
    parentsWithoutDocument: function() {
      return this.parents().filter((elem) => elem !== document);
    },

    /**
     * Traverses up the tree to to get the next closest sibling of a node
     * or any of it's parents.
     *
     * This is used in scenarios where you have already consumed the parents while
     * traversing the tree but not the siblings of parents.
     *
     * @param {HTMLElement | undefined} rootNode  The root node which acts as a threshold
     * for how deep we can go in the tree when getting siblings or their parents.
     *
     * @returns {HTMLElement | null}
     */
    nextClosestSibling: function(rootNode) {
      let current = el;
      let nextClosestSibling;

      do {
        nextClosestSibling = current.nextSibling;
        current = current.parentNode;
      } while (!nextClosestSibling &amp;&amp; current.parentNode &amp;&amp; rootNode.contains(current));

      if (!rootNode.contains(current)) {
        nextClosestSibling = null;
      }
      return nextClosestSibling;
    },

    /**
     * Normalizes text nodes within base element, ie. merges sibling text nodes and assures that every
     * element node has only one text node.
     * It should does the same as standard element.normalize, but IE implements it incorrectly.
     */
    normalizeTextNodes: function() {
      if (!el) {
        return;
      }

      if (el.nodeType === NODE_TYPE.TEXT_NODE) {
        while (el.nextSibling &amp;&amp; el.nextSibling.nodeType === NODE_TYPE.TEXT_NODE) {
          el.nodeValue += el.nextSibling.nodeValue;
          el.parentNode.removeChild(el.nextSibling);
        }
      } else {
        dom(el.firstChild).normalizeTextNodes();
      }
      dom(el.nextSibling).normalizeTextNodes();
    },

    /**
     * Normalizes elements that have the a same id and are next to eachother in the child list
     */
    normalizeElements: function(highlightedClass, dataAttr = DATA_ATTR) {
      if (!el) {
        return;
      }

      if (el.nodeType !== NODE_TYPE.TEXT_NODE) {
        if (isElementHighlight(el, dataAttr)) {
          let className = el.className;
          while (
            className &amp;&amp;
            el.nextSibling &amp;&amp;
            el.nextSibling.nodeType !== NODE_TYPE.TEXT_NODE &amp;&amp;
            el.nextSibling.className === className &amp;&amp;
            className !== highlightedClass
          ) {
            el.innerHTML += el.nextSibling.innerHTML;
            el.parentNode.removeChild(el.nextSibling);
          }
          dom(el.firstChild).normalizeElements(highlightedClass, dataAttr);
        } else {
          let id = el.id;
          while (
            id &amp;&amp;
            el.nextSibling &amp;&amp;
            el.nextSibling.nodeType !== NODE_TYPE.TEXT_NODE &amp;&amp;
            el.nextSibling.id === id
          ) {
            el.innerHTML += el.nextSibling.innerHTML;
            el.parentNode.removeChild(el.nextSibling);
          }
          dom(el.firstChild).normalizeElements(highlightedClass, dataAttr);
        }
      } else {
        dom(el).normalizeTextNodes();
      }
      dom(el.nextSibling).normalizeElements(highlightedClass, dataAttr);
    },

    /**
     * Returns element background color.
     * @returns {CSSStyleDeclaration.backgroundColor}
     */
    color: function() {
      return el.style.backgroundColor;
    },

    /**
     * Creates dom element from given html string.
     * @param {string} html
     * @returns {NodeList}
     */
    fromHTML: function(html) {
      let div = document.createElement("div");
      div.innerHTML = html;
      return div.childNodes;
    },

    /**
     * Returns first range of the window of base element.
     * @returns {Range}
     */
    getRange: function() {
      let selection = dom(el).getSelection(),
        range;

      if (selection.rangeCount > 0) {
        range = selection.getRangeAt(0);
      }

      return range;
    },

    /**
     * Removes all ranges of the window of base element.
     */
    removeAllRanges: function() {
      let selection = dom(el).getSelection();
      selection.removeAllRanges();
    },

    /**
     * Returns selection object of the window of base element.
     * @returns {Selection}
     */
    getSelection: function() {
      return dom(el)
        .getWindow()
        .getSelection();
    },

    /**
     * Returns window of the base element.
     * @returns {Window}
     */
    getWindow: function() {
      return dom(el).getDocument().defaultView;
    },

    /**
     * Returns document of the base element.
     * @returns {HTMLDocument}
     */
    getDocument: function() {
      // if ownerDocument is null then el is the document itself.
      return el.ownerDocument || el;
    },
    /**
     * Returns whether the provided element comes after the base element.
     *
     * @param {HTMLElement} otherElement
     *
     * @returns {boolean}
     */
    isAfter: function(otherElement, rootElement) {
      let sibling = el.nextSibling;
      let isAfter = false;
      while (sibling &amp;&amp; !isAfter) {
        if (sibling === otherElement) {
          isAfter = true;
        } else {
          if (!sibling.nextSibling) {
            sibling = el.parentNode.nextSibling;
          } else {
            sibling = sibling.nextSibling;
          }
        }
      }
      return isAfter;
    },

    /**
     * Extracts all the text content for the root element excluding
     * all the text content inside any of the provided excluded tags.
     *
     * @param {string[]} excludeTags lement tags to exclude
     *
     * @returns {string}
     */
    textContentExcludingTags: function(excludeTags) {
      if (el &amp;&amp; el.nodeType === NODE_TYPE.COMMENT_NODE) {
        return "";
      }
      if (el &amp;&amp; el.nodeType !== NODE_TYPE.TEXT_NODE) {
        // Ensure we simply return the text content in the case the element is a text node.
        const elCopy = el.cloneNode(true);
        let commentsInCopy = [elCopy.querySelectorAll("*")].filter(
          (element) => element.nodeType === NODE_TYPE.COMMENT_NODE,
        );
        commentsInCopy.forEach((toExcludeFromCopy) => {
          toExcludeFromCopy.remove();
        });

        const elementsToBeExcluded = excludeTags.reduce((accum, tag) => {
          return [...accum, ...elCopy.querySelectorAll(tag)];
        }, []);
        elementsToBeExcluded.forEach((toExcludeFromCopy) => {
          toExcludeFromCopy.remove();
        });

        return elCopy.textContent;
      }
      return el.textContent;
    },

    /**
     * Gets the index of a child element in the base element.
     * It is important we use childNodes as we want to include both
     * html element nodes and text nodes.
     *
     * @param {HTMLElement} childElement
     * @return {number}
     */
    getChildIndex: function(childElement) {
      let currentChild = el.firstChild;
      let i = 0;

      while (currentChild &amp;&amp; childElement !== currentChild) {
        if (currentChild !== childElement) {
          currentChild = currentChild.nextSibling;
          i++;
        }
      }

      return currentChild ? i : -1;
    },

    /**
     * Loop through the elements in the dom and remove any events attached to elements that are not text nodes and have no children.
     *
     * @param {listOfElementAttributes} - list of events and their values which have been turned off, along with a temporary id for each element which has been altered.
     */
    turnOffEventHandlers: function(listOfElementAttributes) {
      if (!el) {
        return;
      }
      if (el.childNodes &amp;&amp; el.childNodes.length > 0) {
        dom(el.firstChild).turnOffEventHandlers(listOfElementAttributes);
      } else if (el.nodeType !== NODE_TYPE.TEXT_NODE &amp;&amp; el.attributes) {
        let eventsForObject = dom(el).turnOffEventHandlersForElement();
        if (eventsForObject) {
          listOfElementAttributes.push(eventsForObject);
        }
      }
      dom(el.nextSibling).turnOffEventHandlers(listOfElementAttributes);
    },

    /**
     * Loop through the elements in the dom and add back in any events that were previously removed from elements.
     *
     * @param {listOfElementAttributes} - list of events and their values which have recently been turned off, along with a temporary id for each element which has been altered.
     */
    turnOnEventHandlers: function(listOfElementAttributes) {
      if (!el || !listOfElementAttributes || listOfElementAttributes.length === 0) {
        return;
      }
      let elements = Array.prototype.slice.call(el.querySelectorAll("[temp-id]"));
      listOfElementAttributes.forEach((elementAttribute) => {
        let tempId = elementAttribute.tempId;
        let attributeList = elementAttribute.listOfAttributes;
        let element = elements.filter((element) => element.getAttribute("temp-id") === tempId)[0];
        if (element) {
          dom(element).addAttributes(attributeList);
          element.removeAttribute("temp-id");
        }
      });
    },

    /**
     * Loop through the attributes of an element and turn off all attributes that have names starting with 'on'.
     * This will turn of all events for elements that have no children and are not text nodes (images etc.)
     *
     * @return {object} - list of events and their values which have been turned off
     */
    turnOffEventHandlersForElement: function() {
      if (!el) {
        return null;
      }

      if (
        el.nodeType !== NODE_TYPE.TEXT_NODE &amp;&amp;
        el.nodeType !== NODE_TYPE.COMMENT_NODE &amp;&amp;
        el.childNodes &amp;&amp;
        el.childNodes.length === 0
      ) {
        var attributes = [].slice.call(el.attributes);

        var listOfAttributes = [];
        let i;
        for (i = 0; i &lt; attributes.length; i++) {
          var att = attributes[i].name;
          if (att.indexOf("on") === 0) {
            var eventHandlers = {};
            eventHandlers.attribute = attributes[i].name;
            eventHandlers.value = attributes[i].value;
            listOfAttributes.push(eventHandlers);
            el.attributes.removeNamedItem(att);
          }
        }
        if (listOfAttributes.length > 0) {
          const uniqueId = `hlt-${Math.random()
            .toString(36)
            .substring(2, 15) +
            Math.random()
              .toString(36)
              .substring(2, 15)}`;
          el.setAttribute("temp-id", uniqueId);
          return { tempId: uniqueId, listOfAttributes };
        }
      }
    },

    /**
     * Loop through the a list of attributes and add each and their value to the element.
     *
     * @param {array} - list of attributes and their values
     */
    addAttributes: function(attributes) {
      if (!el) {
        return;
      }
      let i;
      for (i = 0; i &lt; attributes.length; i++) {
        let attribute = attributes[i];
        el.setAttribute(attribute.attribute, attribute.value);
      }
    },
  };
};

export default dom;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Thu Jan 14 2021 15:23:20 GMT+0000 (Greenwich Mean Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
