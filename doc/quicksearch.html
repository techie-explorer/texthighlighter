<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"utils_arrays.js.html":{"id":"utils_arrays.js.html","title":"Source: utils/arrays.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn Source: utils/arrays.js /** * Returns array without duplicated values. * @param {Array} arr * @returns {Array} */ export function unique(arr) { return arr.filter(function(value, idx, self) { return self.indexOf(value) === idx; }); } /** * Returns array of strings with all strings converted to lower case. * * @param {String[]} arr * @returns {String[]} */ export function arrayToLower(arr) { return arr.map(Function.prototype.call, String.prototype.toLowerCase); } × Search results Close "},"utils_highlights.js.html":{"id":"utils_highlights.js.html","title":"Source: utils/highlights.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn Source: utils/highlights.js import dom, { NODE_TYPE } from \"./dom\"; import { DATA_ATTR, START_OFFSET_ATTR, LENGTH_ATTR, TIMESTAMP_ATTR } from \"../config\"; import { arrayToLower } from \"./arrays\"; import { scaleFromTransformMatrix } from \"./transform\"; /** * Takes range object as parameter and refines it boundaries * @param range * @returns {object} refined boundaries and initial state of highlighting algorithm. */ export function refineRangeBoundaries(range) { let startContainer = range.startContainer, endContainer = range.endContainer, ancestor = range.commonAncestorContainer, goDeeper = true; if (range.endOffset === 0) { while (!endContainer.previousSibling &amp;&amp; endContainer.parentNode !== ancestor) { endContainer = endContainer.parentNode; } endContainer = endContainer.previousSibling; } else if (endContainer.nodeType === NODE_TYPE.TEXT_NODE) { if (range.endOffset &lt; endContainer.nodeValue.length) { endContainer.splitText(range.endOffset); } } else if (range.endOffset &gt; 0) { endContainer = endContainer.childNodes.item(range.endOffset - 1); } if (startContainer.nodeType === NODE_TYPE.TEXT_NODE) { if (range.startOffset === startContainer.nodeValue.length) { goDeeper = false; } else if (range.startOffset &gt; 0) { startContainer = startContainer.splitText(range.startOffset); if (endContainer === startContainer.previousSibling) { endContainer = startContainer; } } } else if (range.startOffset &lt; startContainer.childNodes.length) { startContainer = startContainer.childNodes.item(range.startOffset); } else { startContainer = startContainer.nextSibling; } return { startContainer: startContainer, endContainer: endContainer, goDeeper: goDeeper, }; } /** * Sorts array of DOM elements by its depth in DOM tree. * @param {HTMLElement[]} arr - array to sort. * @param {boolean} descending - order of sort. */ export function sortByDepth(arr, descending) { arr.sort(function(a, b) { return dom(descending ? b : a).parents().length - dom(descending ? a : b).parents().length; }); } /** * Returns true if elements a i b have the same color. * @param {Node} a * @param {Node} b * @returns {boolean} */ export function haveSameColor(a, b) { return dom(a).color() === dom(b).color(); } /** * Creates wrapper for highlights. * TextHighlighter instance calls this method each time it needs to create highlights and pass options retrieved * in constructor. * @param {object} options - the same object as in TextHighlighter constructor. * @returns {HTMLElement} */ export function createWrapper(options) { let span = document.createElement(\"span\"); span.style.backgroundColor = options.color; span.className = options.highlightedClass; return span; } export function findTextNodeAtLocation(element, locationInChildNodes) { let textNodeElement = element; let i = 0; while (textNodeElement &amp;&amp; textNodeElement.nodeType !== NODE_TYPE.TEXT_NODE) { if (locationInChildNodes === \"start\") { if (textNodeElement.childNodes.length &gt; 0) { textNodeElement = textNodeElement.childNodes[0]; } else { textNodeElement = textNodeElement.nextSibling; } } else if (locationInChildNodes === \"end\") { if (textNodeElement.childNodes.length &gt; 0) { let lastIndex = textNodeElement.childNodes.length - 1; textNodeElement = textNodeElement.childNodes[lastIndex]; } else { textNodeElement = textNodeElement.previousSibling; } } else { textNodeElement = null; } i++; } return textNodeElement; } function textContentExcludingTags(node, excludeNodeNames) { return dom(node).textContentExcludingTags(arrayToLower(excludeNodeNames)); } /** * Determine where to inject a highlight based on it's offset. * A highlight can span multiple nodes, so in here we accumulate * all those nodes with offset and length of the content in the node * included in the highlight. * * @param {*} highlight * @param {*} parentNode */ export function findNodesAndOffsets(highlight, parentNode, excludeNodeNames = [\"SCRIPT\", \"STYLE\"]) { const nodesAndOffsets = []; let currentNode = parentNode; let currentOffset = 0; const highlightEndOffset = highlight.offset + highlight.length; while (currentNode &amp;&amp; currentOffset &lt; highlightEndOffset) { // Ensure we ignore node types that the caller has specified should be excluded. if (!excludeNodeNames.includes(currentNode.nodeName)) { const textLength = textContentExcludingTags(currentNode, excludeNodeNames).length; const endOfCurrentNodeOffset = currentOffset + textLength; if (endOfCurrentNodeOffset &gt; highlight.offset) { const isTerminalNode = currentNode.childNodes.length === 0; if (isTerminalNode) { if (currentNode.nodeType === NODE_TYPE.TEXT_NODE) { const offsetWithinNode = highlight.offset &gt; currentOffset ? highlight.offset - currentOffset : 0; const lengthInHighlight = highlightEndOffset &gt; endOfCurrentNodeOffset ? textLength - offsetWithinNode : highlightEndOffset - currentOffset - offsetWithinNode; nodesAndOffsets.push({ node: currentNode, offset: offsetWithinNode, length: lengthInHighlight, }); currentOffset = endOfCurrentNodeOffset; } // It doesn't matter if it is a text node or not at this point, // we still need to get the next sibling of the node or it's ancestors. currentNode = dom(currentNode).nextClosestSibling(); } else { currentNode = currentNode.childNodes[0]; } } else { currentOffset = endOfCurrentNodeOffset; currentNode = currentNode.nextSibling; } } else { currentNode = dom(currentNode).nextClosestSibling(); } } return nodesAndOffsets; } export function getElementOffset( childElement, rootElement, excludeNodeNames = [\"SCRIPT\", \"STYLE\"], ) { let offset = 0; let childNodes; let currentElement = childElement; do { // Ensure specified node types are not counted in the offset. if (!excludeNodeNames.includes(currentElement.nodeName)) { childNodes = currentElement.parentNode.childNodes; const childElementIndex = dom(currentElement.parentNode).getChildIndex(currentElement); const offsetInCurrentParent = getTextOffsetBefore( childNodes, childElementIndex, excludeNodeNames, ); offset += offsetInCurrentParent; } currentElement = currentElement.parentNode; } while (currentElement !== rootElement || !currentElement); return offset; } function getTextOffsetBefore(childNodes, cutIndex, excludeNodeNames) { let textOffset = 0; for (let i = 0; i &lt; cutIndex; i++) { const currentNode = childNodes[i]; // Strip out all nodes from the child node that we should be excluding. // // Use textContent and not innerText to account for invisible characters such as carriage returns as well, // plus innerText forces a reflow of the layout and as we access text content of nodes // a lot in the highlighting process, we don't want to take the performance hit. // https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent const text = dom(currentNode).textContentExcludingTags(arrayToLower(excludeNodeNames)); if (!excludeNodeNames.includes(currentNode.nodeName) &amp;&amp; text &amp;&amp; text.length &gt; 0) { textOffset += text.length; } } return textOffset; } export function findFirstNonSharedParent(elements) { let childElement = elements.childElement; let otherElement = elements.otherElement; let parents = dom(childElement).parentsWithoutDocument(); let i = 0; let firstNonSharedParent = null; let allParentsAreShared = false; while (!firstNonSharedParent &amp;&amp; !allParentsAreShared &amp;&amp; i &lt; parents.length) { const currentParent = parents[i]; if (currentParent.contains(otherElement)) { if (i &gt; 0) { firstNonSharedParent = parents[i - 1]; } else { allParentsAreShared = true; } } i++; } return firstNonSharedParent; } function gatherSiblingsUpToEndNode(startNodeOrContainer, endNode) { const gatheredSiblings = []; let foundEndNodeSibling = false; let currentNode = startNodeOrContainer.nextSibling; while (currentNode &amp;&amp; !foundEndNodeSibling) { if (currentNode === endNode || currentNode.contains(endNode)) { foundEndNodeSibling = true; } else { gatheredSiblings.push(currentNode); currentNode = currentNode.nextSibling; } } return { gatheredSiblings, foundEndNodeSibling }; } /** * Gets all the nodes in between the provided start and end. * * @param {HTMLElement} startNode * @param {HTMLElement} endNode * @returns {HTMLElement[]} Nodes that live in between the two. */ export function nodesInBetween(startNode, endNode) { if (startNode === endNode) { return []; } // First attempt the easiest solution, hoping endNode will be at the same level // as the start node or contained in an element at the same level. const { foundEndNodeSibling: foundEndNodeSiblingOnSameLevel, gatheredSiblings, } = gatherSiblingsUpToEndNode(startNode, endNode); if (foundEndNodeSiblingOnSameLevel) { return gatheredSiblings; } // Now go for the route that goes to the highest parent of the start node in the tree // that is not the parent of the end node. const startNodeParent = findFirstNonSharedParent({ childElement: startNode, otherElement: endNode, }); if (startNodeParent) { const { foundEndNodeSibling: foundEndNodeSiblingFromParentLevel, gatheredSiblings: gatheredSiblingsFromParent, } = gatherSiblingsUpToEndNode(startNodeParent, endNode); if (foundEndNodeSiblingFromParentLevel) { return gatheredSiblingsFromParent; } } return []; } /** * Groups given highlights by timestamp. * @param {Array} highlights * @param {string} timestampAttr * @returns {Array} Grouped highlights. */ export function groupHighlights(highlights, timestampAttr) { let order = [], chunks = {}, grouped = []; highlights.forEach(function(hl) { let timestamp = hl.getAttribute(timestampAttr); if (typeof chunks[timestamp] === \"undefined\") { chunks[timestamp] = []; order.push(timestamp); } chunks[timestamp].push(hl); }); order.forEach(function(timestamp) { let group = chunks[timestamp]; grouped.push({ chunks: group, timestamp: timestamp, toString: function() { return group .map(function(h) { return h.textContent; }) .join(\"\"); }, }); }); return grouped; } export function retrieveHighlights(params) { params = { andSelf: true, grouped: false, ...params, }; let nodeList = params.container.querySelectorAll(\"[\" + params.dataAttr + \"]\"), highlights = Array.prototype.slice.call(nodeList); if (params.andSelf === true &amp;&amp; params.container.hasAttribute(params.dataAttr)) { highlights.push(params.container); } if (params.grouped) { highlights = groupHighlights(highlights, params.timestampAttr); } return highlights; } export function isElementHighlight(el, dataAttr) { return el &amp;&amp; el.nodeType === NODE_TYPE.ELEMENT_NODE &amp;&amp; el.hasAttribute(dataAttr); } export function addNodesToHighlightAfterElement({ element, elementAncestor, highlightWrapper, highlightedClass, }) { if (elementAncestor) { if (elementAncestor.classList.contains(highlightedClass)) { // Ensure we only take the children from a parent that is a highlight. elementAncestor.childNodes.forEach((childNode) =&gt; { // if (dom(childNode).isAfter(element)) { // } elementAncestor.appendChild(childNode); }); } else { highlightWrapper.appendChild(elementAncestor); } } else { highlightWrapper.appendChild(element); } } /** * Collects the human-readable highlighted text for all nodes in the selected range. * * @param {Range} range * * @return {string} The human-readable highlighted text for the given range. */ export function getHighlightedTextForRange(range, excludeTags = [\"script\", \"style\"]) { // Strip out all carriage returns and excess html layout space. return dom(range.cloneContents()) .textContentExcludingTags(arrayToLower(excludeTags)) .replace(/\\s{2,}/g, \" \") .replace(\"\\r\\n\", \"\") .replace(\"\\r\", \"\") .replace(\"\\n\", \"\"); } /** * Collects the human-readable highlighted text for all nodes from the start text offset * relative to the root element. * * @param {{ rootElement: HTMLElement, startOffset: number, length: number}} params * The root-relative parameters for extracting highlighted text. * * @return {string} The human-readable highlighted text for the given root element, offset and length. */ export function getHighlightedTextRelativeToRoot({ rootElement, startOffset, length, excludeTags = [\"script\", \"style\"], }) { const textContent = dom(rootElement).textContentExcludingTags(arrayToLower(excludeTags)); const highlightedRawText = textContent.substring( startOffset, Number.parseInt(startOffset) + Number.parseInt(length), ); const textNode = document.createTextNode(highlightedRawText); const tempContainer = document.createElement(\"div\"); tempContainer.appendChild(textNode); // Extract the human-readable text only. return tempContainer.innerText; } export function createDescriptors({ rootElement, range, wrapper, excludeNodeNames = [\"SCRIPT\", \"STYLE\"], }) { const wrapperClone = wrapper.cloneNode(true); const startOffset = getElementOffset(range.startContainer, rootElement, excludeNodeNames) + range.startOffset; const endOffset = range.startContainer === range.endContainer ? startOffset + (range.endOffset - range.startOffset) : getElementOffset(range.endContainer, rootElement, excludeNodeNames) + range.endOffset; const length = endOffset - startOffset; wrapperClone.setAttribute(DATA_ATTR, true); wrapperClone.setAttribute(START_OFFSET_ATTR, startOffset); wrapperClone.setAttribute(LENGTH_ATTR, length); wrapperClone.innerHTML = \"\"; const wrapperHTML = wrapperClone.outerHTML; const descriptor = [ wrapperHTML, // retrieve all the text content between the start and end offsets. getHighlightedTextForRange(range, excludeNodeNames), startOffset, length, ]; return [descriptor]; } /** * * * @param {HTMLElement} node The element we need to get parent information for. * @param {string} id The unique id of the collection of elements representing a highlight. * @param {HTMLElement} rootElement The root element of the context to stop at. * * @return {boolean} */ function isClosestHighlightParent(node, id, rootElement) { let isClosestHighlightParent = true; let currentNode = node.parentNode; while (currentNode &amp;&amp; currentNode !== rootElement &amp;&amp; isClosestHighlightParent) { if (isElementHighlight(currentNode, DATA_ATTR) &amp;&amp; !currentNode.classList.contains(id)) { // The case there is a closer parent than the highlight for the provided id. isClosestHighlightParent = false; } else { currentNode = currentNode.parentNode; } } return isClosestHighlightParent; } /** * Focuses a set of highlight elements for a given id by ensuring if it has descendants that are highlights * it is moved inside of the innermost highlight. * * The innermost highlight's styles will be applied and will be visible to the user * and given the \"focus\". * * To focus the red highlight the following: * * -- &lt;red-highlight&gt; * ---- &lt;blue-highlight&gt; * ------ &lt;green-highlight&gt; * ---------- Highlighted text * * becomes: * * -- &lt;blue-highlight&gt; * ---- &lt;green-highlight&gt; * ------ &lt;red-highlight&gt; * -------- Highlighted text * * and * * -- &lt;red-highlight&gt; * ---- Some text only highlighted in red * ---- &lt;blue-highlight&gt; * ------ Text in blue and red * ------ &lt;green-highlight&gt; * ---------- Rest of the highlight in red, green and blue * * becomes * * -- &lt;red-highlight&gt; * ---- Some text only highlighted in red * -- &lt;blue-highlight&gt; * ---- &lt;red-highlight-copy-1&gt; * ------ Text in blue and red * ---- &lt;green-highlight&gt; * ------ &lt;red-highlight-copy-2&gt; * -------- Rest of the highlight in red, green and blue * * @typedef NodeInfo * @type {object} * @property {HTMLElement} nodeInfo.node The html element (This will in most cases be a text node) * @property {number} nodeInfo.offset The offset within the node to be highlighted * @property {number} nodeInfo.length The length within the node that should be highlighted. * * @param {string} id The unique identifier of a highlight represented by one or more nodes in the DOM. * @param {NodeInfo[]} nodeInfoList The highlight portion node information that should be focused. * @param {HTMLElement} highlightWrapper The highlight wrapper representing the highlight to be focused. * * @param {HTMLElement} rootElement The root context element to normalise elements within. */ export function focusHighlightNodes( id, nodeInfoList, highlightWrapper, rootElement, highlightedClass, ) { nodeInfoList.forEach((nodeInfo) =&gt; { const node = nodeInfo.node; // Only wrap the node if the closest highlight parent isn't one with the given id. if (!isClosestHighlightParent(node, id, rootElement)) { // Ensure any ancestors that aren't direct parents that represent the same highlight wrapper are removed. const ancestors = dom(node).parentsUpTo(rootElement); ancestors.forEach((ancestor) =&gt; { if (isElementHighlight(ancestor, DATA_ATTR) &amp;&amp; ancestor.classList.contains(id)) { // Ensure a copy of the ancestor is wrapped back around any // other children that do not contain the current node. ancestor.childNodes.forEach((ancestorChild) =&gt; { if (!ancestorChild.contains(node)) { const wrapper = highlightWrapper.cloneNode(true); dom(ancestorChild).wrap(wrapper); } }); dom(ancestor).unwrap(); } }); // Now wrap the node or the part of the node the highlight covers directly with the wrapper. let nodeToBeWrapped = node; if (nodeInfo.offset &gt; 0) { nodeToBeWrapped = node.splitText(nodeInfo.offset); } if (nodeInfo.length &lt; nodeToBeWrapped.textContent.length) { nodeToBeWrapped.splitText(nodeInfo.length); } dom(nodeToBeWrapped).wrap(highlightWrapper.cloneNode(true)); } }); // Ensure we normalise all nodes in the root container to merge sibling elements // of the same highlight together that get copied for the purpose of focusing. dom(rootElement).normalizeElements(highlightedClass); } /** * Validation for descriptors to ensure they are of the correct format to be used by the Independencia highlighter. * * @param {array} descriptors The descriptors to be validated. * @return {boolean} - if the descriptors are valid or not. */ export function validateIndependenciaDescriptors(descriptors) { if (descriptors &amp;&amp; descriptors.length === 4) { return true; } return false; } × Search results Close "},"config.js.html":{"id":"config.js.html","title":"Source: config.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn Source: config.js /** * Attribute added by default to every highlight. * @type {string} */ export const DATA_ATTR = \"data-highlighted\"; /** * Attribute used to group highlight wrappers. * @type {string} */ export const TIMESTAMP_ATTR = \"data-timestamp\"; export const START_OFFSET_ATTR = \"data-start-offset\"; export const LENGTH_ATTR = \"data-length\"; /** * Don't highlight content of these tags. * @type {string[]} */ export const IGNORE_TAGS = [ \"SCRIPT\", \"STYLE\", \"SELECT\", \"OPTION\", \"BUTTON\", \"OBJECT\", \"APPLET\", \"VIDEO\", \"AUDIO\", \"CANVAS\", \"EMBED\", \"PARAM\", \"METER\", \"PROGRESS\", ]; × Search results Close "},"utils_dom.js.html":{"id":"utils_dom.js.html","title":"Source: utils/dom.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn Source: utils/dom.js import { isElementHighlight } from \"./highlights\"; import { DATA_ATTR } from \"../config\"; export const NODE_TYPE = { ELEMENT_NODE: 1, TEXT_NODE: 3 }; /** * Utility functions to make DOM manipulation easier. * @param {Node|HTMLElement} [el] - base DOM element to manipulate * @returns {object} * */ const dom = function(el) { return /** @lends dom **/ { /** * Adds class to element. * @param {string} className */ addClass: function(className) { if (el.classList) { el.classList.add(className); } else { el.className += \" \" + className; } }, /** * Removes class from element. * @param {string} className */ removeClass: function(className) { if (el.classList) { el.classList.remove(className); } else { el.className = el.className.replace( new RegExp(\"(^|\\\\b)\" + className + \"(\\\\b|$)\", \"gi\"), \" \", ); } }, /** * Prepends child nodes to base element. * @param {Node[]} nodesToPrepend */ prepend: function(nodesToPrepend) { let nodes = Array.prototype.slice.call(nodesToPrepend), i = nodes.length; while (i--) { el.insertBefore(nodes[i], el.firstChild); } }, /** * Appends child nodes to base element. * @param {Node[]} nodesToAppend */ append: function(nodesToAppend) { let nodes = Array.prototype.slice.call(nodesToAppend); for (let i = 0, len = nodes.length; i &lt; len; ++i) { el.appendChild(nodes[i]); } }, /** * Inserts base element after refEl. * @param {Node} refEl - node after which base element will be inserted * @returns {Node} - inserted element */ insertAfter: function(refEl) { return refEl.parentNode.insertBefore(el, refEl.nextSibling); }, /** * Inserts base element before refEl. * @param {Node} refEl - node before which base element will be inserted * @returns {Node} - inserted element */ insertBefore: function(refEl) { return refEl.parentNode.insertBefore(el, refEl); }, /** * Removes base element from DOM. */ remove: function() { el.parentNode.removeChild(el); el = null; }, /** * Returns true if base element contains given child. * @param {Node|HTMLElement} child * @returns {boolean} */ contains: function(child) { return el !== child &amp;&amp; el.contains(child); }, /** * Wraps base element in wrapper element. * @param {HTMLElement} wrapper * @returns {HTMLElement} wrapper element */ wrap: function(wrapper) { if (el.parentNode) { el.parentNode.insertBefore(wrapper, el); } wrapper.appendChild(el); return wrapper; }, /** * Unwraps base element. * @returns {Node[]} - child nodes of unwrapped element. */ unwrap: function() { let nodes = Array.prototype.slice.call(el.childNodes), wrapper; nodes.forEach(function(node) { wrapper = node.parentNode; dom(node).insertBefore(node.parentNode); }); dom(wrapper).remove(); return nodes; }, /** * Returns array of base element parents. * @returns {HTMLElement[]} */ parents: function() { let parent, path = []; while ((parent = el.parentNode)) { path.push(parent); el = parent; } return path; }, /** * Returns array of base element parents up to the * provided root element. * * @param {HTMLElement} rootElement * @returns {HTMLElement[]} */ parentsUpTo: function(rootElement) { let parent, path = []; while ((parent = el.parentNode) &amp;&amp; parent !== rootElement) { path.push(parent); el = parent; } return path; }, /** * Returns array of base element parents, excluding the document. * @returns {HTMLElement[]} */ parentsWithoutDocument: function() { return this.parents().filter((elem) =&gt; elem !== document); }, /** * Traverses up the tree to to get the next closest sibling of a node * or any of it's parents. * * This is used in scenarios where you have already consumed the parents while * traversing the tree but not the siblings of parents. * * @returns {HTMLElement | null} */ nextClosestSibling: function() { let current = el; let nextClosestSibling; do { nextClosestSibling = current.nextSibling; current = current.parentNode; } while (!nextClosestSibling &amp;&amp; current.parentNode); return nextClosestSibling; }, /** * Normalizes text nodes within base element, ie. merges sibling text nodes and assures that every * element node has only one text node. * It should does the same as standard element.normalize, but IE implements it incorrectly. */ normalizeTextNodes: function() { if (!el) { return; } if (el.nodeType === NODE_TYPE.TEXT_NODE) { while (el.nextSibling &amp;&amp; el.nextSibling.nodeType === NODE_TYPE.TEXT_NODE) { el.nodeValue += el.nextSibling.nodeValue; el.parentNode.removeChild(el.nextSibling); } } else { dom(el.firstChild).normalizeTextNodes(); } dom(el.nextSibling).normalizeTextNodes(); }, /** * Normalizes elements that have the a same id and are next to eachother in the child list */ normalizeElements: function(highlightedClass) { if (!el) { return; } if (el.nodeType !== NODE_TYPE.TEXT_NODE) { if (isElementHighlight(el, DATA_ATTR)) { let className = el.className; while ( className &amp;&amp; el.nextSibling &amp;&amp; el.nextSibling.nodeType !== NODE_TYPE.TEXT_NODE &amp;&amp; el.nextSibling.className === className &amp;&amp; className !== highlightedClass ) { el.innerHTML += el.nextSibling.innerHTML; el.parentNode.removeChild(el.nextSibling); } dom(el.firstChild).normalizeElements(highlightedClass); } else { let id = el.id; while ( id &amp;&amp; el.nextSibling &amp;&amp; el.nextSibling.nodeType !== NODE_TYPE.TEXT_NODE &amp;&amp; el.nextSibling.id === id ) { el.innerHTML += el.nextSibling.innerHTML; el.parentNode.removeChild(el.nextSibling); } dom(el.firstChild).normalizeElements(highlightedClass); } } else { dom(el).normalizeTextNodes(); } dom(el.nextSibling).normalizeElements(highlightedClass); }, /** * Returns element background color. * @returns {CSSStyleDeclaration.backgroundColor} */ color: function() { return el.style.backgroundColor; }, /** * Creates dom element from given html string. * @param {string} html * @returns {NodeList} */ fromHTML: function(html) { let div = document.createElement(\"div\"); div.innerHTML = html; return div.childNodes; }, /** * Returns first range of the window of base element. * @returns {Range} */ getRange: function() { let selection = dom(el).getSelection(), range; if (selection.rangeCount &gt; 0) { range = selection.getRangeAt(0); } return range; }, /** * Removes all ranges of the window of base element. */ removeAllRanges: function() { let selection = dom(el).getSelection(); selection.removeAllRanges(); }, /** * Returns selection object of the window of base element. * @returns {Selection} */ getSelection: function() { return dom(el) .getWindow() .getSelection(); }, /** * Returns window of the base element. * @returns {Window} */ getWindow: function() { return dom(el).getDocument().defaultView; }, /** * Returns document of the base element. * @returns {HTMLDocument} */ getDocument: function() { // if ownerDocument is null then el is the document itself. return el.ownerDocument || el; }, /** * Returns whether the provided element comes after the base element. * * @param {HTMLElement} otherElement * * @returns {boolean} */ isAfter: function(otherElement, rootElement) { let sibling = el.nextSibling; let isAfter = false; while (sibling &amp;&amp; !isAfter) { if (sibling === otherElement) { isAfter = true; } else { if (!sibling.nextSibling) { sibling = el.parentNode.nextSibling; } else { sibling = sibling.nextSibling; } } } return isAfter; }, /** * Extracts all the text content for the root element excluding * all the text content inside any of the provided excluded tags. * * @param {string[]} excludeTags lement tags to exclude * * @returns {string} */ textContentExcludingTags: function(excludeTags) { // Ensure we simply return the text content in the case the element is a text node. if (el &amp;&amp; el.nodeType !== NODE_TYPE.TEXT_NODE) { const elCopy = el.cloneNode(true); const elementsToBeExcluded = excludeTags.reduce((accum, tag) =&gt; { return [...accum, ...elCopy.querySelectorAll(tag)]; }, []); elementsToBeExcluded.forEach((toExcludeFromCopy) =&gt; { toExcludeFromCopy.remove(); }); return elCopy.textContent; } return el.textContent; }, /** * Gets the index of a child element in the base element. * It is important we use childNodes as we want to include both * html element nodes and text nodes. * * @param {HTMLElement} childElement * @return {number} */ getChildIndex: function(childElement) { let currentChild = el.firstChild; let i = 0; while (currentChild &amp;&amp; childElement !== currentChild) { if (currentChild !== childElement) { currentChild = currentChild.nextSibling; i++; } } return currentChild ? i : -1; }, /** * Loop through the elements in the dom and remove any events attached to elements that are not text nodes and have no children. * * @param {listOfElementAttributes} - list of events and their values which have been turned off, along with a temporary id for each element which has been altered. */ turnOffEventHandlers: function(listOfElementAttributes) { if (!el) { return; } if (el.childNodes &amp;&amp; el.childNodes.length &gt; 0) { dom(el.firstChild).turnOffEventHandlers(listOfElementAttributes); } else if (el.nodeType !== NODE_TYPE.TEXT_NODE) { let eventsForObject = dom(el).turnOffEventHandlersForElement(); if (eventsForObject) { listOfElementAttributes.push(eventsForObject); } } dom(el.nextSibling).turnOffEventHandlers(listOfElementAttributes); }, /** * Loop through the elements in the dom and add back in any events that were previously removed from elements. * * @param {listOfElementAttributes} - list of events and their values which have recently been turned off, along with a temporary id for each element which has been altered. */ turnOnEventHandlers: function(listOfElementAttributes) { if (!el || !listOfElementAttributes || listOfElementAttributes.length === 0) { return; } let elements = Array.prototype.slice.call(el.querySelectorAll(\"[temp-id]\")); listOfElementAttributes.forEach((elementAttribute) =&gt; { let tempId = elementAttribute.tempId; let attributeList = elementAttribute.listOfAttributes; let element = elements.filter((element) =&gt; element.getAttribute(\"temp-id\") === tempId)[0]; if (element) { dom(element).addAttributes(attributeList); element.removeAttribute(\"temp-id\"); } }); }, /** * Loop through the attributes of an element and turn off all attributes that have names starting with 'on'. * This will turn of all events for elements that have no children and are not text nodes (images etc.) * * @return {object} - list of events and their values which have been turned off */ turnOffEventHandlersForElement: function() { if (!el) { return null; } if (el.nodeType !== NODE_TYPE.TEXT_NODE &amp;&amp; el.childNodes &amp;&amp; el.childNodes.length === 0) { var attributes = [].slice.call(el.attributes); var listOfAttributes = []; let i; for (i = 0; i &lt; attributes.length; i++) { var att = attributes[i].name; if (att.indexOf(\"on\") === 0) { var eventHandlers = {}; eventHandlers.attribute = attributes[i].name; eventHandlers.value = attributes[i].value; listOfAttributes.push(eventHandlers); el.attributes.removeNamedItem(att); } } if (listOfAttributes.length &gt; 0) { const uniqueId = `hlt-${Math.random() .toString(36) .substring(2, 15) + Math.random() .toString(36) .substring(2, 15)}`; el.setAttribute(\"temp-id\", uniqueId); return { tempId: uniqueId, listOfAttributes }; } } }, /** * Loop through the a list of attribues and add each and their value to the element. * * @param {array} - list of attributes and their values */ addAttributes: function(attributes) { if (!el) { return; } let i; for (i = 0; i &lt; attributes.length; i++) { let attribute = attributes[i]; el.setAttribute(attribute.attribute, attribute.value); } }, }; }; export default dom; × Search results Close "},"jquery-plugin.js.html":{"id":"jquery-plugin.js.html","title":"Source: jquery-plugin.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn Source: jquery-plugin.js /* global jQuery TextHighlighter */ if (typeof jQuery !== \"undefined\") { (function($) { \"use strict\"; const PLUGIN_NAME = \"textHighlighter\"; function wrap(fn, wrapper) { return function() { wrapper.call(this, fn); }; } /** * The jQuery plugin namespace. * @external \"jQuery.fn\" * @see {@link http://docs.jquery.com/Plugins/Authoring The jQuery Plugin Guide} */ /** * Creates TextHighlighter instance and applies it to the given jQuery object. * @param {object} options Same as {@link TextHighlighter} options. * @returns {jQuery} * @example $('#sandbox').textHighlighter({ color: 'red' }); * @function external:\"jQuery.fn\".textHighlighter */ $.fn.textHighlighter = function(options) { return this.each(function() { let el = this, hl; if (!$.data(el, PLUGIN_NAME)) { hl = new TextHighlighter(el, options); hl.destroy = wrap(hl.destroy, function(destroy) { destroy.call(hl); $(el).removeData(PLUGIN_NAME); }); $.data(el, PLUGIN_NAME, hl); } }); }; $.fn.getHighlighter = function() { return this.data(PLUGIN_NAME); }; })(jQuery); } × Search results Close "},"global-script.js.html":{"id":"global-script.js.html","title":"Source: global-script.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn Source: global-script.js // Core JavaScript polyfills for ES latest features in IE11. import \"core-js/stable\"; import \"regenerator-runtime/runtime\"; import TextHighlighter from \"./text-highlighter\"; /** * Expose the TextHighlighter class globally to be * used in demos and to be injected directly into html files. */ global.TextHighlighter = TextHighlighter; /** * Load the jquery plugin globally expecting jQuery and TextHighlighter to be globally * avaiable, this means this library doesn't need a hard requirement of jQuery. */ import \"./jquery-plugin\"; × Search results Close "},"highlighters_independencia.js.html":{"id":"highlighters_independencia.js.html","title":"Source: highlighters/independencia.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn Source: highlighters/independencia.js import { retrieveHighlights, isElementHighlight, sortByDepth, findNodesAndOffsets, createWrapper, createDescriptors, getHighlightedTextRelativeToRoot, focusHighlightNodes, validateIndependenciaDescriptors, } from \"../utils/highlights\"; import { START_OFFSET_ATTR, LENGTH_ATTR, DATA_ATTR, TIMESTAMP_ATTR } from \"../config\"; import dom from \"../utils/dom\"; /** * IndependenciaHighlighter that provides text highlighting functionality to dom elements * with a focus on removing interdependence between highlights and other element nodes in the context element. * * @typedef {Object} HlDescriptor * @property {string} 0 - The span wrapper injected for the highlight. * @property {string} 1 - The highlighted text. * @property {number} 2 - The text offset relevant to the root element of a highlight. * @property {number} 3 - Length of highlight. * * @typedef {Object} PreprocessDescriptorsResult * @property {HlDescriptor[]} descriptors * @property {Object} meta - Any application-specific meta data created in the preprocessing stage that is * used after highlights have been created. * * @callback PreprocessDescriptors * @param {Range} range * @param {HlDescriptor[]} highlightDescriptors * @param {number} timestamp * @return {PreprocessDescriptorsResult} * * @callback OnAfterHighlightCallbackV2 * @param {Range} range * @param {HlDescriptor[]} highlightDescriptors * @param {number} timestamp * @param {Object} meta */ class IndependenciaHighlighter { /** * Creates an IndependenciaHighlighter instance for functionality that focuses for highlight independence. * * @param {HTMLElement} element - DOM element to which highlighted will be applied. * @param {object} [options] - additional options. * @param {string} options.color - highlight color. * @param {string} options.excludeNodes - Node types to exclude when calculating offsets and determining where to inject highlights. * @param {boolean} options.normalizeElements - Whether or not to normalise elements on the DOM when highlights are created, deserialised * into the DOM, focused and deselected. Normalising events has a huge performance implication when enabling highlighting for a root element * that contains thousands of nodes. * @param {string} options.highlightedClass - class added to highlight, 'highlighted' by default. * @param {string} options.contextClass - class added to element to which highlighter is applied, * 'highlighter-context' by default. * @param {function} options.onRemoveHighlight - function called before highlight is removed. Highlight is * passed as param. Function should return true if highlight should be removed, or false - to prevent removal. * @param {function} options.onBeforeHighlight - function called before highlight is created. Range object is * passed as param. Function should return true to continue processing, or false - to prevent highlighting. * @param {PreprocessDescriptors} options.preprocessDescriptors - function called after the user has carried out the action * to trigger creation of highlights after making a text selection. This should be used to customise the highlight span wrapper * with custom data attributes or styles required before the highlight is loaded into the DOM. * This callback must return an array of highlight descriptors. * @param {OnAfterHighlightCallbackV2} options.onAfterHighlight - function called after highlight is created. Array of created * wrappers is passed as param. This is called after the highlight has been created in the DOM. * @class IndependenciaHighlighter */ constructor(element, options) { this.el = element; this.options = options; this.removedHighlights = {}; } /** * Highlights current range. * @param {boolean} keepRange - Don't remove range after highlighting. Default: false. * @memberof IndependenciaHighlighter */ doHighlight(keepRange) { let range = dom(this.el).getRange(), wrapper, timestamp; if (!range || range.collapsed) { return; } let eventItems = []; dom(this.el).turnOffEventHandlers(eventItems); if (this.options.onBeforeHighlight(range) === true) { timestamp = +new Date(); wrapper = createWrapper(this.options); wrapper.setAttribute(TIMESTAMP_ATTR, timestamp); const descriptors = createDescriptors({ rootElement: this.el, range, wrapper, excludeNodeNames: this.options.excludeNodes, }); const { descriptors: processedDescriptors, meta } = this.options.preprocessDescriptors( range, descriptors, timestamp, ); this.deserializeHighlights(JSON.stringify(processedDescriptors)); this.options.onAfterHighlight(range, processedDescriptors, timestamp, meta); } if (!keepRange) { dom(this.el).removeAllRanges(); } dom(this.el).turnOnEventHandlers(eventItems); } /** * Normalizes highlights and the dom. Ensures text nodes within any given element node are merged together, elements with the * same ID next to each other are merged together and highlights with the same ID next to each other are merged together. * * @memberof IndependenciaHighlighter */ normalizeHighlights() { dom(this.el).normalizeElements(this.options.highlightedClass); } /** * Removes one highlight if an ID is provided, removes all highlights in the provided * element otherwise. * * @param {HTMLElement} element - element to remove highlights from * @param {string} id - ID of highlight to remove * Removes highlights from element using highlight ID. * If no id is given, all highlights are removed. * @memberof IndependenciaHighlighter */ removeHighlights(element, id) { const container = element || this.el; let highlights = this.getHighlights({ container }), self = this; highlights.forEach(function(hl) { if (!id || (id &amp;&amp; hl.classList.contains(id))) { let highlightId = hl.classList.length &gt; 1 ? hl.classList[1] : null; if (highlightId &amp;&amp; self.removedHighlights[highlightId]) { dom(hl).unwrap(); } else if (self.options.onRemoveHighlight(hl) === true) { dom(hl).unwrap(); if (highlightId) { self.removedHighlights[highlightId] = true; } } } }); if (this.options.normalizeElements) { this.normalizeHighlights(highlights); } } /** * Returns highlights from given container. * @param params * @param {HTMLElement} [params.container] - return highlights from this element. Default: the element the * highlighter is applied to. * @param {boolean} [params.andSelf] - if set to true and container is a highlight itself, add container to * returned results. Default: true. * @param {boolean} [params.grouped] - if set to true, highlights are grouped in logical groups of highlights added * in the same moment. Each group is an object which has got array of highlights, 'toString' method and 'timestamp' * property. Default: false. * @returns {Array} - array of highlights. * @memberof IndependenciaHighlighter */ getHighlights(params) { const mergedParams = { container: this.el, dataAttr: DATA_ATTR, timestampAttr: TIMESTAMP_ATTR, ...params, }; return retrieveHighlights(mergedParams); } /** * Returns true if element is a highlight. * * @param el - element to check. * @param dataAttr - data attribute to determine if the element is a highlight * @returns {boolean} * @memberof IndependenciaHighlighter */ isHighlight(el, dataAttr) { return isElementHighlight(el, dataAttr); } /** * Serializes the highlight belonging to the ID. * @param id - ID of the highlight to serialise * @returns {string} - stringified JSON with highlights definition * @memberof IndependenciaHighlighter */ serializeHighlights(id) { const highlights = this.getHighlights(), self = this; sortByDepth(highlights, false); if (highlights.length === 0) { return []; } let eventItems = []; dom(this.el).turnOffEventHandlers(eventItems); // Even if there are multiple elements for a given highlight, the first // highlight in the DOM with the given ID in it's class name // will have all the information we need. const highlight = highlights.find((hl) =&gt; hl.classList.contains(id)); if (!highlight) { return []; } const length = highlight.getAttribute(LENGTH_ATTR); const offset = highlight.getAttribute(START_OFFSET_ATTR); const wrapper = highlight.cloneNode(true); wrapper.innerHTML = \"\"; const wrapperHTML = wrapper.outerHTML; const descriptor = [ wrapperHTML, getHighlightedTextRelativeToRoot({ rootElement: self.el, startOffset: offset, length, excludeTags: this.options.excludeNodes, }), offset, length, ]; dom(this.el).turnOnEventHandlers(eventItems); return JSON.stringify([descriptor]); } /** * Deserializes the independent form of highlights. * * @throws exception when can't parse JSON or JSON has invalid structure. * @param {object} json - JSON object with highlights definition. * @returns {Array} - array of deserialized highlights. * @memberof IndependenciaHighlighter */ deserializeHighlights(json) { let hlDescriptors, highlights = [], self = this; if (!json) { return highlights; } try { hlDescriptors = JSON.parse(json); } catch (e) { throw \"Can't parse JSON: \" + e; } let eventItems = []; dom(this.el).turnOffEventHandlers(eventItems); function deserialise(hlDescriptor) { let hl = { wrapper: hlDescriptor[0], text: hlDescriptor[1], offset: Number.parseInt(hlDescriptor[2]), length: Number.parseInt(hlDescriptor[3]), }, hlNode, highlight; const parentNode = self.el; const highlightNodes = findNodesAndOffsets(hl, parentNode, self.options.excludeNodes); highlightNodes.forEach(({ node, offset: offsetWithinNode, length: lengthInNode }) =&gt; { // Don't call innerText to prevent DOM layout reflow. // Visible text content may be a bit of naive name but represents // everything excluding new lines and white space. const visibleTextContent = node.textContent.trim().replace(/(\\r\\n|\\n|\\r)/gm, \"\"); if (visibleTextContent.length &gt; 0) { hlNode = node.splitText(offsetWithinNode); hlNode.splitText(lengthInNode); if (hlNode.nextSibling &amp;&amp; !hlNode.nextSibling.nodeValue) { dom(hlNode.nextSibling).remove(); } if (hlNode.previousSibling &amp;&amp; !hlNode.previousSibling.nodeValue) { dom(hlNode.previousSibling).remove(); } highlight = dom(hlNode).wrap(dom().fromHTML(hl.wrapper)[0]); highlights.push(highlight); } }); } hlDescriptors.forEach(function(hlDescriptor) { try { if (validateIndependenciaDescriptors(hlDescriptor)) { deserialise(hlDescriptor); } else { console.warn( \"Can't deserialize highlight descriptors. Cause: descriptors are not valid.\", ); } } catch (e) { if (console &amp;&amp; console.warn) { console.warn(\"Can't deserialize highlight descriptor. Cause: \" + e); } } }); if (this.options.normalizeElements) { this.normalizeHighlights(); } dom(this.el).turnOnEventHandlers(eventItems); return highlights; } /** * Focuses a highlight, bringing it forward in the case it is sitting behind another * overlapping highlight, or a highlight it is nested inside. * * @param {object} id - The id of the highlight present in the class names of all elements * in the DOM that represent the highlight. * * In order to utilise this functionality unique ids for highlights should be added to the class list in the highlight * wrapper within the descriptors. * You can do this in the onAfterHighlight callback when a highlight is first created. * * In the future it might be worth adding more flexiblity to allow for user-defined ways of storing ids to identify * elements in the DOM. (e.g. choosing between class name or data attributes) * * @param {string} descriptors - Optional serialised descriptors, useful in the case a highlight has no representation in the DOM * where empty highlight wrapper nodes are removed to use less dom elements. * * @memberof IndependenciaHighlighter */ focusUsingId(id, descriptors) { const highlightElements = this.el.querySelectorAll(`.${id}`); let eventItems = []; dom(this.el).turnOffEventHandlers(eventItems); // For the future, we may save by accepting the offset and length as parameters as the caller should have this data // from the serialised descriptors. if (highlightElements.length &gt; 0) { const firstHighlightElement = highlightElements[0]; const nodesAndOffsets = findNodesAndOffsets( { offset: Number.parseInt(firstHighlightElement.getAttribute(START_OFFSET_ATTR)), length: Number.parseInt(firstHighlightElement.getAttribute(LENGTH_ATTR)), }, this.el, this.options.excludeNodes, ); const highlightWrapper = firstHighlightElement.cloneNode(true); highlightWrapper.innerHTML = \"\"; focusHighlightNodes( id, nodesAndOffsets, highlightWrapper, this.el, this.options.highlightedClass, ); } else if (descriptors) { // No elements in the DOM for the highlight? // let's deserialize the descriptor to bring the highlight into focus. this.deserializeHighlights(descriptors); } dom(this.el).turnOnEventHandlers(eventItems); } /** * Deselects a highlight, bringing any nested highlights in the list of descriptors * forward. * * In order to utilise this functionality unique ids for highlights should be added to the class list in the highlight * wrapper within the descriptors. * You can do this in the onAfterHighlight callback when a highlight is first created. * * In the future it might be worth adding more flexiblity to allow for user-defined ways of storing ids to identify * elements in the DOM. (e.g. choosing between class name or data attributes) * * @typedef HighlightDescriptor * @type {object} * @property {string} id * @property {string} serialisedDescriptor * * @param {string} id The id of the deselected highlight. * @param {HighlightDescriptor[]} descriptors An array of serialised descriptors containing all the relevant highlights * that could be nested within the deselected highlight. * * @memberof IndependenciaHighlighter */ deselectUsingId(id, descriptors) { const deselectedHighlight = this.el.querySelector(`.${id}`); if (deselectedHighlight) { const deselectedStartOffset = Number.parseInt( deselectedHighlight.getAttribute(START_OFFSET_ATTR), ); const deselectedLength = Number.parseInt(deselectedHighlight.getAttribute(LENGTH_ATTR)); const nestedDescriptors = descriptors .map((hlDescriptor) =&gt; ({ id: hlDescriptor.id, descriptor: JSON.parse(hlDescriptor.serialisedDescriptor), })) .filter((hlDescriptor) =&gt; { const innerDescriptor = hlDescriptor.descriptor[0]; const offset = Number.parseInt(innerDescriptor[2]); const length = Number.parseInt(innerDescriptor[3]); return ( offset &gt;= deselectedStartOffset &amp;&amp; offset + length &lt;= deselectedStartOffset + deselectedLength ); }); nestedDescriptors.sort((a, b) =&gt; { const aLength = Number.parseInt(a.descriptor[0][3]); const bLength = Number.parseInt(b.descriptor[0][3]); return aLength &gt; bLength ? -1 : 1; }); nestedDescriptors.forEach((hlDescriptor) =&gt; { this.focusUsingId(hlDescriptor.id, JSON.stringify(hlDescriptor.descriptor)); }); } } } export default IndependenciaHighlighter; × Search results Close "},"highlighters_primitivo.js.html":{"id":"highlighters_primitivo.js.html","title":"Source: highlighters/primitivo.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn Source: highlighters/primitivo.js import { refineRangeBoundaries, retrieveHighlights, isElementHighlight, sortByDepth, haveSameColor, createWrapper, } from \"../utils/highlights\"; import dom, { NODE_TYPE } from \"../utils/dom\"; import { IGNORE_TAGS, DATA_ATTR, TIMESTAMP_ATTR } from \"../config\"; import { unique } from \"../utils/arrays\"; /** * PrimitivoHighlighter that provides text highlighting functionality to dom elements * for simple use cases. * * @callback onAfterHighlightCallbackV1 * @param {Range} range * @param {HTMLElement[]} highlights * @param {number} timestamp */ class PrimitivoHighlighter { /** * Creates a PrimitivoHighlighter instance for functionality specific to the original implementation. * * @param {HTMLElement} element - DOM element to which highlighted will be applied. * @param {object} [options] - additional options. * @param {string} options.color - highlight color. * @param {string} options.highlightedClass - class added to highlight, 'highlighted' by default. * @param {string} options.contextClass - class added to element to which highlighter is applied, * 'highlighter-context' by default. * @param {function} options.onRemoveHighlight - function called before highlight is removed. Highlight is * passed as param. Function should return true if highlight should be removed, or false - to prevent removal. * @param {function} options.onBeforeHighlight - function called before highlight is created. Range object is * passed as param. Function should return true to continue processing, or false - to prevent highlighting. * @param {onAfterHighlightCallbackV1} options.onAfterHighlight - function called after highlight is created. Array of created * wrappers is passed as param. * @class PrimitivoHighlighter */ constructor(element, options) { this.el = element; this.options = options; } /** * Highlights range. * Wraps text of given range object in wrapper element. * @param {Range} range * @param {HTMLElement} wrapper * @returns {Array} - array of created highlights. * @memberof PrimitivoHighlighter */ highlightRange(range, wrapper) { if (!range || range.collapsed) { return []; } let result = refineRangeBoundaries(range), startContainer = result.startContainer, endContainer = result.endContainer, goDeeper = result.goDeeper, done = false, node = startContainer, highlights = [], highlight, wrapperClone, nodeParent; do { if (goDeeper &amp;&amp; node.nodeType === NODE_TYPE.TEXT_NODE) { if (IGNORE_TAGS.indexOf(node.parentNode.tagName) === -1 &amp;&amp; node.nodeValue.trim() !== \"\") { wrapperClone = wrapper.cloneNode(true); wrapperClone.setAttribute(DATA_ATTR, true); nodeParent = node.parentNode; // highlight if a node is inside the el if (dom(this.el).contains(nodeParent) || nodeParent === this.el) { highlight = dom(node).wrap(wrapperClone); highlights.push(highlight); } } goDeeper = false; } if (node === endContainer &amp;&amp; !(endContainer.hasChildNodes() &amp;&amp; goDeeper)) { done = true; } if (node.tagName &amp;&amp; IGNORE_TAGS.indexOf(node.tagName) &gt; -1) { if (endContainer.parentNode === node) { done = true; } goDeeper = false; } if (goDeeper &amp;&amp; node.hasChildNodes()) { node = node.firstChild; } else if (node.nextSibling) { node = node.nextSibling; goDeeper = true; } else { node = node.parentNode; goDeeper = false; } } while (!done); return highlights; } /** * Normalizes highlights. Ensures that highlighting is done with use of the smallest possible number of * wrapping HTML elements. * Flattens highlights structure and merges sibling highlights. Normalizes text nodes within highlights. * @param {Array} highlights - highlights to normalize. * @returns {Array} - array of normalized highlights. Order and number of returned highlights may be different than * input highlights. * @memberof PrimitivoHighlighter */ normalizeHighlights(highlights) { var normalizedHighlights; this.flattenNestedHighlights(highlights); this.mergeSiblingHighlights(highlights); // omit removed nodes normalizedHighlights = highlights.filter(function(hl) { return hl.parentElement ? hl : null; }); normalizedHighlights = unique(normalizedHighlights); normalizedHighlights.sort(function(a, b) { return a.offsetTop - b.offsetTop || a.offsetLeft - b.offsetLeft; }); return normalizedHighlights; } /** * Flattens highlights structure. * Note: this method changes input highlights - their order and number after calling this method may change. * @param {Array} highlights - highlights to flatten. * @memberof PrimitivoHighlighter */ flattenNestedHighlights(highlights) { let again, self = this; sortByDepth(highlights, true); function flattenOnce() { let again = false; highlights.forEach(function(hl, i) { let parent = hl.parentElement, parentPrev = parent.previousSibling, parentNext = parent.nextSibling; if (self.isHighlight(parent, DATA_ATTR)) { if (!haveSameColor(parent, hl)) { if (!hl.nextSibling) { if (!parentNext) { dom(hl).insertAfter(parent); } else { dom(hl).insertBefore(parentNext); } dom(hl).insertBefore(parentNext || parent); again = true; } if (!hl.previousSibling) { if (!parentPrev) { dom(hl).insertBefore(parent); } else { dom(hl).insertAfter(parentPrev); } dom(hl).insertAfter(parentPrev || parent); again = true; } if ( hl.previousSibling &amp;&amp; hl.previousSibling.nodeType == 3 &amp;&amp; hl.nextSibling &amp;&amp; hl.nextSibling.nodeType == 3 ) { let spanleft = document.createElement(\"span\"); spanleft.style.backgroundColor = parent.style.backgroundColor; spanleft.className = parent.className; let timestamp = parent.attributes[TIMESTAMP_ATTR].nodeValue; spanleft.setAttribute(TIMESTAMP_ATTR, timestamp); spanleft.setAttribute(DATA_ATTR, true); let spanright = spanleft.cloneNode(true); dom(hl.previousSibling).wrap(spanleft); dom(hl.nextSibling).wrap(spanright); let nodes = Array.prototype.slice.call(parent.childNodes); nodes.forEach(function(node) { dom(node).insertBefore(node.parentNode); }); again = true; } if (!parent.hasChildNodes()) { dom(parent).remove(); } } else { parent.replaceChild(hl.firstChild, hl); highlights[i] = parent; again = true; } } }); return again; } do { again = flattenOnce(); } while (again); } /** * Merges sibling highlights and normalizes descendant text nodes. * Note: this method changes input highlights - their order and number after calling this method may change. * @param highlights * @memberof PrimitivoHighlighter */ mergeSiblingHighlights(highlights) { var self = this; function shouldMerge(current, node) { return ( node &amp;&amp; node.nodeType === NODE_TYPE.ELEMENT_NODE &amp;&amp; haveSameColor(current, node) &amp;&amp; self.isHighlight(node, DATA_ATTR) ); } highlights.forEach(function(highlight) { var prev = highlight.previousSibling, next = highlight.nextSibling; if (shouldMerge(highlight, prev)) { dom(highlight).prepend(prev.childNodes); dom(prev).remove(); } if (shouldMerge(highlight, next)) { dom(highlight).append(next.childNodes); dom(next).remove(); } dom(highlight).normalizeTextNodes(); }); } /** * Highlights current range. * @param {boolean} keepRange - Don't remove range after highlighting. Default: false. * @memberof PrimitivoHighlighter */ doHighlight(keepRange) { let range = dom(this.el).getRange(), wrapper, createdHighlights, normalizedHighlights, timestamp; if (!range || range.collapsed) { return; } if (this.options.onBeforeHighlight(range) === true) { timestamp = +new Date(); wrapper = createWrapper(this.options); wrapper.setAttribute(TIMESTAMP_ATTR, timestamp); createdHighlights = this.highlightRange(range, wrapper); normalizedHighlights = this.normalizeHighlights(createdHighlights); this.options.onAfterHighlight(range, normalizedHighlights, timestamp); } if (!keepRange) { dom(this.el).removeAllRanges(); } } /** * Removes highlights from element. If element is a highlight itself, it is removed as well. * If no element is given, all highlights all removed. * @param {HTMLElement} [element] - element to remove highlights from * @memberof PrimitivoHighlighter */ removeHighlights(element) { var container = element || this.el, highlights = this.getHighlights({ container: container }), self = this; function mergeSiblingTextNodes(textNode) { var prev = textNode.previousSibling, next = textNode.nextSibling; if (prev &amp;&amp; prev.nodeType === NODE_TYPE.TEXT_NODE) { textNode.nodeValue = prev.nodeValue + textNode.nodeValue; dom(prev).remove(); } if (next &amp;&amp; next.nodeType === NODE_TYPE.TEXT_NODE) { textNode.nodeValue = textNode.nodeValue + next.nodeValue; dom(next).remove(); } } function removeHighlight(highlight) { var textNodes = dom(highlight).unwrap(); textNodes.forEach(function(node) { mergeSiblingTextNodes(node); }); } sortByDepth(highlights, true); highlights.forEach(function(hl) { if (self.options.onRemoveHighlight(hl) === true) { removeHighlight(hl); } }); } /** * Returns highlights from given container. * @param params * @param {HTMLElement} [params.container] - return highlights from this element. Default: the element the * highlighter is applied to. * @param {boolean} [params.andSelf] - if set to true and container is a highlight itself, add container to * returned results. Default: true. * @param {boolean} [params.grouped] - if set to true, highlights are grouped in logical groups of highlights added * in the same moment. Each group is an object which has got array of highlights, 'toString' method and 'timestamp' * property. Default: false. * @returns {Array} - array of highlights. * @memberof PrimitivoHighlighter */ getHighlights(params) { const mergedParams = { container: this.el, dataAttr: DATA_ATTR, timestampAttr: TIMESTAMP_ATTR, ...params, }; return retrieveHighlights(mergedParams); } /** * Returns true if element is a highlight. * * @param el - element to check. * @returns {boolean} * @memberof PrimitivoHighlighter */ isHighlight(el, dataAttr) { return isElementHighlight(el, dataAttr); } /** * Serializes all highlights in the element the highlighter is applied to. * @returns {string} - stringified JSON with highlights definition * @memberof PrimitivoHighlighter */ serializeHighlights() { let highlights = this.getHighlights(), refEl = this.el, hlDescriptors = []; function getElementPath(el, refElement) { let path = [], childNodes; do { childNodes = Array.prototype.slice.call(el.parentNode.childNodes); path.unshift(childNodes.indexOf(el)); el = el.parentNode; } while (el !== refElement || !el); return path; } sortByDepth(highlights, false); highlights.forEach(function(highlight) { let offset = 0, // Hl offset from previous sibling within parent node. length = highlight.textContent.length, hlPath = getElementPath(highlight, refEl), wrapper = highlight.cloneNode(true); wrapper.innerHTML = \"\"; wrapper = wrapper.outerHTML; if (highlight.previousSibling &amp;&amp; highlight.previousSibling.nodeType === NODE_TYPE.TEXT_NODE) { offset = highlight.previousSibling.length; } hlDescriptors.push([wrapper, highlight.textContent, hlPath.join(\":\"), offset, length]); }); return JSON.stringify(hlDescriptors); } /** * Deserializes highlights. * @throws exception when can't parse JSON or JSON has invalid structure. * @param {object} json - JSON object with highlights definition. * @returns {Array} - array of deserialized highlights. * @memberof PrimitivoHighlighter */ deserializeHighlights(json) { let hlDescriptors, highlights = [], self = this; if (!json) { return highlights; } try { hlDescriptors = JSON.parse(json); } catch (e) { throw \"Can't parse JSON: \" + e; } function deserializationFn(hlDescriptor) { let hl = { wrapper: hlDescriptor[0], text: hlDescriptor[1], path: hlDescriptor[2].split(\":\"), offset: hlDescriptor[3], length: hlDescriptor[4], }, elIndex = hl.path.pop(), node = self.el, hlNode, highlight, idx; while ((idx = hl.path.shift())) { node = node.childNodes[idx]; } if ( node.childNodes[elIndex - 1] &amp;&amp; node.childNodes[elIndex - 1].nodeType === NODE_TYPE.TEXT_NODE ) { elIndex -= 1; } node = node.childNodes[elIndex]; hlNode = node.splitText(hl.offset); hlNode.splitText(hl.length); if (hlNode.nextSibling &amp;&amp; !hlNode.nextSibling.nodeValue) { dom(hlNode.nextSibling).remove(); } if (hlNode.previousSibling &amp;&amp; !hlNode.previousSibling.nodeValue) { dom(hlNode.previousSibling).remove(); } highlight = dom(hlNode).wrap(dom().fromHTML(hl.wrapper)[0]); highlights.push(highlight); } hlDescriptors.forEach(function(hlDescriptor) { try { deserializationFn(hlDescriptor); } catch (e) { if (console &amp;&amp; console.warn) { console.warn(\"Can't deserialize highlight descriptor. Cause: \" + e); } } }); return highlights; } } export default PrimitivoHighlighter; × Search results Close "},"utils_transform.js.html":{"id":"utils_transform.js.html","title":"Source: utils/transform.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn Source: utils/transform.js /** * Extracts the scale from a 2D transform matrix. * * @param {string} transformMatrix The 2D transform matrix. * * @return {number} The combined scale element of the transform. */ export function scaleFromTransformMatrix(transformMatrix) { const matrixValues = transformMatrix .split(\"(\")[1] .split(\"(\")[0] .split(\",\"); const a = matrixValues[0]; const b = matrixValues[1]; return Math.sqrt(a * a + b * b); } × Search results Close "},"text-highlighter.js.html":{"id":"text-highlighter.js.html","title":"Source: text-highlighter.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn Source: text-highlighter.js import dom from \"./utils/dom\"; import { bindEvents, unbindEvents } from \"./utils/events\"; import Primitivo from \"./highlighters/primitivo\"; import Independencia from \"./highlighters/independencia\"; import { DATA_ATTR } from \"./config\"; import { createWrapper } from \"./utils/highlights\"; const highlighters = { primitivo: Primitivo, \"v1-2014\": Primitivo, independencia: Independencia, \"v2-2019\": Independencia, }; const versionNames = { \"v1-2014\": \"Primitivo (v1-2014)\", primitivo: \"Primitivo (v1-2014)\", \"v2-2019\": \"Independencia (v2-2019)\", independencia: \"Independencia (v2-2019)\", }; /** * TextHighlighter that provides text highlighting functionality to dom elements. */ class TextHighlighter { /** * Creates wrapper for highlights. * TextHighlighter instance calls this method each time it needs to create highlights and pass options retrieved * in constructor. * * @param {object} options - the same object as in TextHighlighter constructor. * @returns {HTMLElement} */ static createWrapper(options) { return createWrapper(options); } /** * Creates TextHighlighter instance and binds to given DOM elements. * * @param {HTMLElement} element - DOM element to which highlighted will be applied. * @param {object} [options] - additional options. * @param {string} options.version - The version of the text highlighting functionality to use. * There are two options: * primitivo (v1-2014) is for the initial implementation using interdependent highlight locators. * (Lots of issues for requirements beyond simple all or nothing highlights) * * independencia (v2-2019) is for an improved implementation focusing on making highlights independent * from eachother and other element nodes within the context DOM object. v2 uses data attributes * as the source of truth about the text range selected to create the original highlight. * This allows us freedom to manipulate the DOM at will and handle overlapping highlights a lot better. * * @param {string} [options.color=#ffff7b] - highlight color. * @param {string[]} [options.excludeNodes=[\"SCRIPT\",\"STYLE\"]] - Node types to exclude when calculating offsets and determining where to inject highlights. * @param {string} [options.highlightedClass=highlighted] - class added to highlight, 'highlighted' by default. * @param {string} [options.contextClass=highlighter-context] - class added to element to which highlighter is applied, * 'highlighter-context' by default. * @param {boolean} [options.useDefaultEvents=true] - Whether or not to use the default events to listen for text selections. * The default events are \"mouseup\" and \"touchend\". Set this to false and register TextHiglighter.highlightHandler with your own events. * It is down to you to remove the listener from your custom events when destroying instances of the text highlighter. * @param {boolean} [options.normalizeElements=false] - Whether or not to normalise elements on the DOM when highlights are created, deserialised * into the DOM, focused and deselected. Normalising events has a huge performance implication when enabling highlighting for a root element * that contains thousands of nodes. This only applies for the independencia v2-2019 version. * @param {function} options.onRemoveHighlight - function called before highlight is removed. Highlight is * passed as param. Function should return true if highlight should be removed, or false - to prevent removal. * @param {function} options.onBeforeHighlight - function called before highlight is created. Range object is * passed as param. Function should return true to continue processing, or false - to prevent highlighting. * @param {function} options.preprocessDescriptors - function called when a user has made a selection to create a highlight, * this is called before the highlight are loaded into the DOM. This should be used to carry out tasks like customising the span wrapper * used to inject highlights with data attributes specific to your application. (This is only utilised by v2-2019 onwards) * @param {function} options.onAfterHighlight - function called after highlight is created. Array of created * wrappers is passed as param. This is called once the highlights have been loaded into the DOM. * (The callback interface differs between versions, see specific highlighter classes for more info) * * @param {boolean} registerEventsOnConstruction - Whether or not to attempt to register events when the text highlighter is first instantiated. * In the case options.useDefaultEvents is false, even with this enabled the events won't be registered, this is only relevant if you want more * control and register events at a later point. */ constructor(element, options = {}, registerEventsOnConstruction = true) { if (!element) { throw new Error(\"Missing anchor element\"); } this.el = element; this.options = { color: \"#ffff7b\", highlightedClass: \"highlighted\", contextClass: \"highlighter-context\", version: \"independencia\", useDefaultEvents: true, excludeNodes: [\"SCRIPT\", \"STYLE\"], normalizeElements: false, onRemoveHighlight: function() { return true; }, onBeforeHighlight: function() { return true; }, preprocessDescriptors: function(_, hlts) { // We need to return the highlight descriptors parameter by // default in order to create highlights in the DOM. // Also an empty meta object is needed given that it is expected in the interface. return { descriptors: hlts, meta: {} }; }, onAfterHighlight: function() {}, ...options, }; if (!highlighters[this.options.version]) { throw new Error(\"Please provide a valid version of the text highlighting functionality\"); } this.highlighter = new highlighters[this.options.version](this.el, this.options); dom(this.el).addClass(this.options.contextClass); if (registerEventsOnConstruction) { this.registerDefaultEvents(); } } /** * Permanently disables highlighting. * Unbinds events and remove context element class. * @memberof TextHighlighter */ destroy() { if (this.options.useDefaultEvents) { unbindEvents(this.el, this); } dom(this.el).removeClass(this.options.contextClass); } /** * Registers the default event listeners that trigger the proecss * of creating a highlight. * * @memberof TextHighlighter */ registerDefaultEvents() { if (this.options.useDefaultEvents) { bindEvents(this.el, this); } } /** * Listener to events that can trigger the creation of a highlight. * By default this is triggered on \"mouseup\" and \"touchend\" events. * If you disable the default events by setting options.useDefaultEvents * you will need to register this handler with your own events and make sure you * remove the listener when you destroy the instance of the TextHighlighter as well. */ highlightHandler() { this.doHighlight(); } doHighlight(keepRange) { this.highlighter.doHighlight(keepRange); } /** * Highlights range. * Wraps text of given range object in wrapper element. * @param {Range} range * @param {HTMLElement} wrapper * @returns {Array} - array of created highlights. * @memberof TextHighlighter */ highlightRange(range, wrapper) { return this.highlighter.highlightRange(range, wrapper); } /** * Normalizes highlights. Ensure at least text nodes are normalized, carries out some flattening and nesting * where necessary. * * @param {Array} highlights - highlights to normalize. * @returns {Array} - array of normalized highlights. Order and number of returned highlights may be different than * input highlights. * @memberof TextHighlighter */ normalizeHighlights(highlights) { return this.highlighter.normalizeHighlights(highlights); } /** * Sets highlighting color. * @param {string} color - valid CSS color. * @memberof TextHighlighter */ setColor(color) { this.options.color = color; } /** * Returns highlighting color. * @returns {string} * @memberof TextHighlighter */ getColor() { return this.options.color; } /** * Removes highlights from element. If element is a highlight itself, it is removed as well. * If no element is given, all highlights all removed. * @param {HTMLElement} element - element to remove highlights from. * if empty, the root element of the highlighter will be used. * @param {string} id - The unique id of a highlight represented by a collection of elements. * @memberof TextHighlighter */ removeHighlights(element, id) { this.highlighter.removeHighlights(element, id); } /** * Returns highlights from given container. * @param params * @param {HTMLElement} [params.container] - return highlights from this element. Default: the element the * highlighter is applied to. * @param {boolean} [params.andSelf] - if set to true and container is a highlight itself, add container to * returned results. Default: true. * @param {boolean} [params.grouped] - if set to true, highlights are grouped in logical groups of highlights added * in the same moment. Each group is an object which has got array of highlights, 'toString' method and 'timestamp' * property. Default: false. * @returns {Array} - array of highlights. * @memberof TextHighlighter */ getHighlights(params) { return this.highlighter.getHighlights(params); } /** * Returns true if element is a highlight. * All highlights have 'data-highlighted' attribute. * @param el - element to check. * @returns {boolean} * @memberof TextHighlighter */ isHighlight(el) { return this.highlighter.isHighlight(el, DATA_ATTR); } /** * Serializes all highlights in the element the highlighter is applied to. * the id is not used in the initial version of the highlighter. * * @param {string} id - The unique identifier grouping a set of highlight elements together. * @returns {string} - stringified JSON with highlights definition * @memberof TextHighlighter */ serializeHighlights(id) { return this.highlighter.serializeHighlights(id); } /** * Deserializes highlights. * @throws exception when can't parse JSON or JSON has invalid structure. * @param {object} json - JSON object with highlights definition. * @returns {Array} - array of deserialized highlights. * @memberof TextHighlighter */ deserializeHighlights(json) { return this.highlighter.deserializeHighlights(json); } /** * Finds and highlights given text. * @param {string} text - text to search for * @param {boolean} [caseSensitive] - if set to true, performs case sensitive search (default: true) * @memberof TextHighlighter */ find(text, caseSensitive) { let wnd = dom(this.el).getWindow(), scrollX = wnd.scrollX, scrollY = wnd.scrollY, caseSens = typeof caseSensitive === \"undefined\" ? true : caseSensitive; dom(this.el).removeAllRanges(); if (wnd.find) { while (wnd.find(text, caseSens)) { this.doHighlight(true); } } else if (wnd.document.body.createTextRange) { let textRange = wnd.document.body.createTextRange(); textRange.moveToElementText(this.el); while (textRange.findText(text, 1, caseSens ? 4 : 0)) { if ( !dom(this.el).contains(textRange.parentElement()) &amp;&amp; textRange.parentElement() !== this.el ) { break; } textRange.select(); this.doHighlight(true); textRange.collapse(false); } } dom(this.el).removeAllRanges(); wnd.scrollTo(scrollX, scrollY); } /** * Focuses a highlight, bringing it forward in the case it is sitting behind another * overlapping highlight, or a highlight it is nested inside. * * This is only supported by independencia (v2-2019) and onwards. * For older versions, this will simply do nothing. * * @param {string} id - The id of the highlight present in the class names of all elements * in the DOM that represent the highlight. * * @param {string} descriptors - Optional serialised descriptors, useful in the case a highlight has no representation in the DOM * where empty highlight wrapper nodes are removed to use less dom elements. * * @memberof TextHighlighter */ focusUsingId(id, descriptors) { if (this.highlighter.focusUsingId) { this.highlighter.focusUsingId(id, descriptors); } else { console.warn( `The ${ versionNames[this.options.version] } version of the text highlighter does not support focusing highlights.`, ); } } /** * Deselects a highlight, bringing any nested highlights in the list of descriptors * forward. * * This is only supported by independencia (v2-2019) and onwards. * For older versions, this will simply do nothing. * * @typedef HighlightDescriptor * @type {object} * @property {string} id * @property {string} serialisedDescriptor * * @param {string} id The id of the deselected highlight. * @param {HighlightDescriptor[]} descriptors the serialised highlight descriptors for a set of highlights that could be nested * in the deselected highlight. * @memberof TextHighlighter */ deselectUsingId(id, descriptors) { if (this.highlighter.deselectUsingId) { this.highlighter.deselectUsingId(id, descriptors); } else { console.warn( `The ${ versionNames[this.options.version] } version of the text highlighter does not support deselecting highlights.`, ); } } } export default TextHighlighter; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn Global Members &lt;constant&gt; DATA_ATTR :string Attribute added by default to every highlight. Type: string Source: config.js, line 5 &lt;constant&gt; IGNORE_TAGS :Array.&lt;string&gt; Don't highlight content of these tags. Type: Array.&lt;string&gt; Source: config.js, line 19 &lt;constant&gt; TIMESTAMP_ATTR :string Attribute used to group highlight wrappers. Type: string Source: config.js, line 11 Methods arrayToLower(arr) Returns array of strings with all strings converted to lower case. Parameters: Name Type Description arr Array.&lt;String&gt; Source: utils/arrays.js, line 18 Returns: Type Array.&lt;String&gt; createWrapper(options) Creates wrapper for highlights. TextHighlighter instance calls this method each time it needs to create highlights and pass options retrieved in constructor. Parameters: Name Type Description options object the same object as in TextHighlighter constructor. Source: utils/highlights.js, line 80 Returns: Type HTMLElement dom( [el]) Utility functions to make DOM manipulation easier. Parameters: Name Type Argument Description el Node | HTMLElement &lt;optional&gt; base DOM element to manipulate Source: utils/dom.js, line 11 Returns: Type object findNodesAndOffsets(highlight, parentNode) Determine where to inject a highlight based on it's offset. A highlight can span multiple nodes, so in here we accumulate all those nodes with offset and length of the content in the node included in the highlight. Parameters: Name Type Description highlight * parentNode * Source: utils/highlights.js, line 126 getHighlightedTextForRange(range) Collects the human-readable highlighted text for all nodes in the selected range. Parameters: Name Type Description range Range Source: utils/highlights.js, line 404 Returns: The human-readable highlighted text for the given range. Type string getHighlightedTextRelativeToRoot(params) Collects the human-readable highlighted text for all nodes from the start text offset relative to the root element. Parameters: Name Type Description params Object The root-relative parameters for extracting highlighted text. Source: utils/highlights.js, line 424 Returns: The human-readable highlighted text for the given root element, offset and length. Type string groupHighlights(highlights, timestampAttr) Groups given highlights by timestamp. Parameters: Name Type Description highlights Array timestampAttr string Source: utils/highlights.js, line 315 Returns: Grouped highlights. Type Array haveSameColor(a, b) Returns true if elements a i b have the same color. Parameters: Name Type Description a Node b Node Source: utils/highlights.js, line 69 Returns: Type boolean isClosestHighlightParent(node, id, rootElement) Parameters: Name Type Description node HTMLElement The element we need to get parent information for. id string The unique id of the collection of elements representing a highlight. rootElement HTMLElement The root element of the context to stop at. Source: utils/highlights.js, line 487 Returns: Type boolean nodesInBetween(startNode, endNode) Gets all the nodes in between the provided start and end. Parameters: Name Type Description startNode HTMLElement endNode HTMLElement Source: utils/highlights.js, line 273 Returns: Nodes that live in between the two. Type Array.&lt;HTMLElement&gt; refineRangeBoundaries(range) Takes range object as parameter and refines it boundaries Parameters: Name Type Description range Source: utils/highlights.js, line 11 Returns: refined boundaries and initial state of highlighting algorithm. Type object scaleFromTransformMatrix(transformMatrix) Extracts the scale from a 2D transform matrix. Parameters: Name Type Description transformMatrix string The 2D transform matrix. Source: utils/transform.js, line 8 Returns: The combined scale element of the transform. Type number sortByDepth(arr, descending) Sorts array of DOM elements by its depth in DOM tree. Parameters: Name Type Description arr Array.&lt;HTMLElement&gt; array to sort. descending boolean order of sort. Source: utils/highlights.js, line 57 unique(arr) Returns array without duplicated values. Parameters: Name Type Description arr Array Source: utils/arrays.js, line 6 Returns: Type Array validateIndependenciaDescriptors(descriptors) Validation for descriptors to ensure they are of the correct format to be used by the Independencia highlighter. Parameters: Name Type Description descriptors array The descriptors to be validated. Source: utils/highlights.js, line 609 Returns: if the descriptors are valid or not. Type boolean Type Definitions NodeInfo Focuses a set of highlight elements for a given id by ensuring if it has descendants that are highlights it is moved inside of the innermost highlight. The innermost highlight's styles will be applied and will be visible to the user and given the \"focus\". To focus the red highlight the following: -- ---- ------ ---------- Highlighted text becomes: -- ---- ------ -------- Highlighted text and -- ---- Some text only highlighted in red ---- ------ Text in blue and red ------ ---------- Rest of the highlight in red, green and blue becomes -- ---- Some text only highlighted in red -- ---- ------ Text in blue and red ---- ------ -------- Rest of the highlight in red, green and blue Type: object Properties: Name Type Description nodeInfo.node HTMLElement The html element (This will in most cases be a text node) nodeInfo.offset number The offset within the node to be highlighted nodeInfo.length number The length within the node that should be highlighted. Source: utils/highlights.js, line 503 onAfterHighlightCallbackV1(range, highlights, timestamp) PrimitivoHighlighter that provides text highlighting functionality to dom elements for simple use cases. Parameters: Name Type Description range Range highlights Array.&lt;HTMLElement&gt; timestamp number Source: highlighters/primitivo.js, line 13 OnAfterHighlightCallbackV2(range, highlightDescriptors, timestamp, range, highlightDescriptors, timestamp, meta) IndependenciaHighlighter that provides text highlighting functionality to dom elements with a focus on removing interdependence between highlights and other element nodes in the context element. Parameters: Name Type Description range Range highlightDescriptors Array.&lt;HlDescriptor&gt; timestamp number range Range highlightDescriptors Array.&lt;HlDescriptor&gt; timestamp number meta Object Properties: Name Type Description 0 string The span wrapper injected for the highlight. 1 string The highlighted text. 2 number The text offset relevant to the root element of a highlight. 3 number Length of highlight. descriptors Array.&lt;HlDescriptor&gt; meta Object Any application-specific meta data created in the preprocessing stage that is used after highlights have been created. Source: highlighters/independencia.js, line 15 Returns: Type PreprocessDescriptorsResult × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn Classes Classes IndependenciaHighlighter PrimitivoHighlighter TextHighlighter × Search results Close "},"externals.list.html":{"id":"externals.list.html","title":"Externals","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn Externals Classes IndependenciaHighlighter PrimitivoHighlighter TextHighlighter × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn TextHighlighter TextHighlighter allows you to highlight text on web pages. Just select it! Getting started Using the library as an npm package Install the library by running: $ npm install @perlego/text-highlighter Then you can use it like so: import TextHighlighter from '@perlego/text-highlighter'; // Example using a React ref if you are building a react application. const highlighter = new TextHighlighter(sandboxRef.current); // Example using an element accessed directly from the DOM. const highlighter = new TextHighlighter(document.getElementById(\"sandbox\")); Supporting IE11 One thing to note when using this library as a package, you are responsible for providing the polyfills for the core JavaScript features outlined in the latest ECMAScript specifications. Within this library we use features such as Array.prototype.includes and Array.prototype.find which aren't support by IE11 without polyfills. You will need to install core-js and regenerator-runtime. npm install --save core-js regenerator-runtime You can add the following two lines at the BEGINNING of your application's entrypoint file (index.js or main.js): import \"core-js/stable\"; import \"regenerator-runtime/runtime\"; Using the library as a script file Clone down this repository, checkout to the release tag representing the version you would like to use. (2.x.x + only, this won't work for 1.x.x, please refer to the documentation provided with 1.x.x releases) Ensure grunt is installed globally: npm install -g grunt Build the minified version of the library using the following command: npm run build Copy the script file from build/prod/TextHighlighter.min.js to the head section of your web page: &lt;script type=\"text/javascript\" src=\"TextHighlighter.min.js\"&gt;&lt;/script&gt; And use it! var hltr = new TextHighlighter(document.body); Features Highlighting of selected text. Highlighting all occurrences of given text (find &amp; highlight). Removing highlights. Selecting highlight color. Serialization &amp; deserialization. Focusing &amp; deselecting overlapping highlights. Works well in iframes. Keeps DOM clean. No dependencies (apart from core-js and regenerator-runtime for IE11). No jQuery or other libraries needed. Using the library You can find the API reference here which details the interface for the highlighter and the utility functionality that you could also make use of in your project. Simple example import TextHighlighter from '@perlego/text-highlighter'; import { isDuplicate } from './utils'; import highlightsApi from './services/highlights-api'; class ArticleView { constructor(data) { this.data = data; const pageElement = document.getElementById(\"article\"); this.highlighter = new TextHighlighter( pageElement, { version: \"independencia\", onBeforeHighlight: this.onBeforeHighlight, onAfterHighlight: this.onAfterHighlight, preprocessDescriptors: this.preprocessDescriptors, onRemoveHighlight: this.onRemoveHighlight }); } onBeforeHighlight = (range) =&gt; { return !isDuplicate(range) } onRemoveHighlight = (highlightElement) =&gt; { const proceed = window.confirm(\"Are you sure you want to remove this highlight?\"); return proceed; } preprocessDescriptors = (range, descriptors, timestamp) =&gt; { // Add an ID to the class list to identify each highlight // (A highlight can be represented by a group of elements in the DOM). const uniqueId = `hlt-${Math.random() .toString(36) .substring(2, 15) + Math.random() .toString(36) .substring(2, 15)}`; const descriptorsWithIds = descriptors.map(descriptor =&gt; { const [wrapper, ...rest] = descriptor; return [ wrapper.replace( 'class=\"highlighted\"', `class=\"highlighted ${uniqueId}\"` ), ...rest ]; }); return { descriptors: descriptorsWithIds, meta: { id: uniqueId } }; } onAfterHighlight = (range, descriptors, timestamp, meta) =&gt; { highlightsApi.saveBatch(meta.id, descriptorsWithIds) .then((result) =&gt; { // Do something with the highlights that have been saved. }) .catch((err) =&gt; console.error(err)); } render = () =&gt; { // Code that takes the data for the article and adds it to the DOM // based on a html template here. } } Example disabling default event binding For the case where you want to trigger the process of creating highlights from a custom event fired in your application you can do something like the following: import TextHighlighter from '@perlego/text-highlighter'; import { isDuplicate } from './utils'; import highlightsApi from './services/highlights-api'; class ArticleView { constructor(data) { this.data = data; const pageElement = document.getElementById(\"article\"); this.createButton = document.getElementById(\"create-highlight\"); this.highlighter = new TextHighlighter( pageElement, { version: \"independencia\", useDefaultEvents: false, onBeforeHighlight: this.onBeforeHighlight, onAfterHighlight: this.onAfterHighlight, preprocessDescriptors: this.preprocessDescriptors, onRemoveHighlight: this.onRemoveHighlight }); // Add your custom event handler. this.highlightHandler = highlighter.highlightHandler.bind(highlighter); createButton.addEventListener(\"click\", this.highlightHandler); } // Your custom method that ensures the event handler is removed from the button click. destroy() { createButton.removeEventListener(\"click\", this.highlightHanlder); } onBeforeHighlight = (range) =&gt; { return !isDuplicate(range) } onRemoveHighlight = (highlightElement) =&gt; { const proceed = window.confirm(\"Are you sure you want to remove this highlight?\"); return proceed; } preprocessDescriptors = (range, descriptors, timestamp) =&gt; { // Add an ID to the class list to identify each highlight // (A highlight can be represented by a group of elements in the DOM). const uniqueId = `hlt-${Math.random() .toString(36) .substring(2, 15) + Math.random() .toString(36) .substring(2, 15)}`; const descriptorsWithIds = descriptors.map(descriptor =&gt; { const [wrapper, ...rest] = descriptor; return [ wrapper.replace( 'class=\"highlighted\"', `class=\"highlighted ${uniqueId}\"` ), ...rest ]; }); return { descriptors: descriptorsWithIds, meta: { id: uniqueId } }; } onAfterHighlight = (range, descriptors, timestamp, meta) =&gt; { highlightsApi.saveBatch(meta.id, descriptorsWithIds) .then((result) =&gt; { // Do something with the highlights that have been saved. }) .catch((err) =&gt; console.error(err)); } render = () =&gt; { // Code that takes the data for the article and adds it to the DOM // based on a html template here. } } Options Compatibility Should work in all decent browsers and IE 11. Running the tests First run npm install from the root directory of the repo to install all the test runner dependencies. To run both integration and unit tests at once use the following: npm run test:all Integration tests The integration tests covers the integration of the larger components that make up the highlighting functionality such as serialisation + deserialisation, focusing, deselecting, normalisation and interaction with callbacks. To run the integration tests use the following command: npm run test:integration Unit tests The unit tests cover functions that make up the smaller components that query, manipulate the DOM along with pure utility pieces. To run the unit tests use the following command: npm run test:unit Running the Primitivo tests (The first version of the highlighter) The first version of the highlighter contains tests in a standalone jasmine runner that runs in the browser. To run those tests, first set up the server: node webserver.js Then go to http://localhost:5002/test/test.html and the tests will run on page load. Building the API reference documentation Ensure all dev dependencies are installed using: npm install Ensure grunt is installed globally: npm install -g grunt To build the documentation, run the following command: grunt jsdoc Ensure the test server is running: node webserver.js Then go to http://localhost:5002/doc to see the API reference for the library. Demos Simple demo Callbacks Serialization Serialization (Absolutely positioned elements) Iframe Documentation You may check API reference or Wiki pages on GitHub. × Search results Close "},"external-_jQuery.fn_.html":{"id":"external-_jQuery.fn_.html","title":"External: jQuery.fn","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn External: jQuery.fn jQuery.fn The jQuery plugin namespace. Source: jquery-plugin.js, line 15 See: The jQuery Plugin Guide Methods &lt;static&gt; textHighlighter(options) Creates TextHighlighter instance and applies it to the given jQuery object. Parameters: Name Type Description options object Same as TextHighlighter options. Source: jquery-plugin.js, line 21 Returns: Type jQuery Example $('#sandbox').textHighlighter({ color: 'red' }); × Search results Close "},"IndependenciaHighlighter.html":{"id":"IndependenciaHighlighter.html","title":"Class: IndependenciaHighlighter","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn Class: IndependenciaHighlighter IndependenciaHighlighter new IndependenciaHighlighter(element [, options]) Creates an IndependenciaHighlighter instance for functionality that focuses for highlight independence. Parameters: Name Type Argument Description element HTMLElement DOM element to which highlighted will be applied. options object &lt;optional&gt; additional options. Properties Name Type Description color string highlight color. excludeNodes string Node types to exclude when calculating offsets and determining where to inject highlights. normalizeElements boolean Whether or not to normalise elements on the DOM when highlights are created, deserialised into the DOM, focused and deselected. Normalising events has a huge performance implication when enabling highlighting for a root element that contains thousands of nodes. highlightedClass string class added to highlight, 'highlighted' by default. contextClass string class added to element to which highlighter is applied, 'highlighter-context' by default. onRemoveHighlight function function called before highlight is removed. Highlight is passed as param. Function should return true if highlight should be removed, or false - to prevent removal. onBeforeHighlight function function called before highlight is created. Range object is passed as param. Function should return true to continue processing, or false - to prevent highlighting. preprocessDescriptors PreprocessDescriptors function called after the user has carried out the action to trigger creation of highlights after making a text selection. This should be used to customise the highlight span wrapper with custom data attributes or styles required before the highlight is loaded into the DOM. This callback must return an array of highlight descriptors. onAfterHighlight OnAfterHighlightCallbackV2 function called after highlight is created. Array of created wrappers is passed as param. This is called after the highlight has been created in the DOM. Source: highlighters/independencia.js, line 43 Methods deserializeHighlights(json) Deserializes the independent form of highlights. Parameters: Name Type Description json object JSON object with highlights definition. Source: highlighters/independencia.js, line 259 Throws: exception when can't parse JSON or JSON has invalid structure. Returns: array of deserialized highlights. Type Array doHighlight(keepRange) Highlights current range. Parameters: Name Type Description keepRange boolean Don't remove range after highlighting. Default: false. Source: highlighters/independencia.js, line 79 focusUsingId(id, descriptors) Focuses a highlight, bringing it forward in the case it is sitting behind another overlapping highlight, or a highlight it is nested inside. Parameters: Name Type Description id object The id of the highlight present in the class names of all elements in the DOM that represent the highlight. In order to utilise this functionality unique ids for highlights should be added to the class list in the highlight wrapper within the descriptors. You can do this in the onAfterHighlight callback when a highlight is first created. In the future it might be worth adding more flexiblity to allow for user-defined ways of storing ids to identify elements in the DOM. (e.g. choosing between class name or data attributes) descriptors string Optional serialised descriptors, useful in the case a highlight has no representation in the DOM where empty highlight wrapper nodes are removed to use less dom elements. Source: highlighters/independencia.js, line 357 getHighlights(params) Returns highlights from given container. Parameters: Name Type Description params Properties Name Type Argument Description container HTMLElement &lt;optional&gt; return highlights from this element. Default: the element the highlighter is applied to. andSelf boolean &lt;optional&gt; if set to true and container is a highlight itself, add container to returned results. Default: true. grouped boolean &lt;optional&gt; if set to true, highlights are grouped in logical groups of highlights added in the same moment. Each group is an object which has got array of highlights, 'toString' method and 'timestamp' property. Default: false. Source: highlighters/independencia.js, line 176 Returns: array of highlights. Type Array isHighlight(el, dataAttr) Returns true if element is a highlight. Parameters: Name Type Description el element to check. dataAttr data attribute to determine if the element is a highlight Source: highlighters/independencia.js, line 194 Returns: Type boolean normalizeHighlights() Normalizes highlights and the dom. Ensures text nodes within any given element node are merged together, elements with the same ID next to each other are merged together and highlights with the same ID next to each other are merged together. Source: highlighters/independencia.js, line 125 removeHighlights(element, id) Removes one highlight if an ID is provided, removes all highlights in the provided element otherwise. Parameters: Name Type Description element HTMLElement element to remove highlights from id string ID of highlight to remove Removes highlights from element using highlight ID. If no id is given, all highlights are removed. Source: highlighters/independencia.js, line 139 serializeHighlights(id) Serializes the highlight belonging to the ID. Parameters: Name Type Description id ID of the highlight to serialise Source: highlighters/independencia.js, line 204 Returns: stringified JSON with highlights definition Type string Type Definitions HighlightDescriptor Deselects a highlight, bringing any nested highlights in the list of descriptors forward. In order to utilise this functionality unique ids for highlights should be added to the class list in the highlight wrapper within the descriptors. You can do this in the onAfterHighlight callback when a highlight is first created. In the future it might be worth adding more flexiblity to allow for user-defined ways of storing ids to identify elements in the DOM. (e.g. choosing between class name or data attributes) Type: object Properties: Name Type Description id string serialisedDescriptor string Source: highlighters/independencia.js, line 393 × Search results Close "},"PrimitivoHighlighter.html":{"id":"PrimitivoHighlighter.html","title":"Class: PrimitivoHighlighter","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn Class: PrimitivoHighlighter PrimitivoHighlighter new PrimitivoHighlighter(element [, options]) Creates a PrimitivoHighlighter instance for functionality specific to the original implementation. Parameters: Name Type Argument Description element HTMLElement DOM element to which highlighted will be applied. options object &lt;optional&gt; additional options. Properties Name Type Description color string highlight color. highlightedClass string class added to highlight, 'highlighted' by default. contextClass string class added to element to which highlighter is applied, 'highlighter-context' by default. onRemoveHighlight function function called before highlight is removed. Highlight is passed as param. Function should return true if highlight should be removed, or false - to prevent removal. onBeforeHighlight function function called before highlight is created. Range object is passed as param. Function should return true to continue processing, or false - to prevent highlighting. onAfterHighlight onAfterHighlightCallbackV1 function called after highlight is created. Array of created wrappers is passed as param. Source: highlighters/primitivo.js, line 23 Methods deserializeHighlights(json) Deserializes highlights. Parameters: Name Type Description json object JSON object with highlights definition. Source: highlighters/primitivo.js, line 417 Throws: exception when can't parse JSON or JSON has invalid structure. Returns: array of deserialized highlights. Type Array doHighlight(keepRange) Highlights current range. Parameters: Name Type Description keepRange boolean Don't remove range after highlighting. Default: false. Source: highlighters/primitivo.js, line 263 flattenNestedHighlights(highlights) Flattens highlights structure. Note: this method changes input highlights - their order and number after calling this method may change. Parameters: Name Type Description highlights Array highlights to flatten. Source: highlighters/primitivo.js, line 143 getHighlights(params) Returns highlights from given container. Parameters: Name Type Description params Properties Name Type Argument Description container HTMLElement &lt;optional&gt; return highlights from this element. Default: the element the highlighter is applied to. andSelf boolean &lt;optional&gt; if set to true and container is a highlight itself, add container to returned results. Default: true. grouped boolean &lt;optional&gt; if set to true, highlights are grouped in logical groups of highlights added in the same moment. Each group is an object which has got array of highlights, 'toString' method and 'timestamp' property. Default: false. Source: highlighters/primitivo.js, line 345 Returns: array of highlights. Type Array highlightRange(range, wrapper) Highlights range. Wraps text of given range object in wrapper element. Parameters: Name Type Description range Range wrapper HTMLElement Source: highlighters/primitivo.js, line 53 Returns: array of created highlights. Type Array isHighlight(el) Returns true if element is a highlight. Parameters: Name Type Description el element to check. Source: highlighters/primitivo.js, line 362 Returns: Type boolean mergeSiblingHighlights(highlights) Merges sibling highlights and normalizes descendant text nodes. Note: this method changes input highlights - their order and number after calling this method may change. Parameters: Name Type Description highlights Source: highlighters/primitivo.js, line 229 normalizeHighlights(highlights) Normalizes highlights. Ensures that highlighting is done with use of the smallest possible number of wrapping HTML elements. Flattens highlights structure and merges sibling highlights. Normalizes text nodes within highlights. Parameters: Name Type Description highlights Array highlights to normalize. Source: highlighters/primitivo.js, line 118 Returns: array of normalized highlights. Order and number of returned highlights may be different than input highlights. Type Array removeHighlights( [element]) Removes highlights from element. If element is a highlight itself, it is removed as well. If no element is given, all highlights all removed. Parameters: Name Type Argument Description element HTMLElement &lt;optional&gt; element to remove highlights from Source: highlighters/primitivo.js, line 296 serializeHighlights() Serializes all highlights in the element the highlighter is applied to. Source: highlighters/primitivo.js, line 371 Returns: stringified JSON with highlights definition Type string × Search results Close "},"TextHighlighter.html":{"id":"TextHighlighter.html","title":"Class: TextHighlighter","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRuniquevalidateIndependenciaDescriptors Externals jQuery.fn Class: TextHighlighter TextHighlighter TextHighlighter that provides text highlighting functionality to dom elements. new TextHighlighter(element [, options], registerEventsOnConstruction) Creates TextHighlighter instance and binds to given DOM elements. Parameters: Name Type Argument Description element HTMLElement DOM element to which highlighted will be applied. options object &lt;optional&gt; additional options. Properties Name Type Argument Default Description version string The version of the text highlighting functionality to use. There are two options: primitivo (v1-2014) is for the initial implementation using interdependent highlight locators. (Lots of issues for requirements beyond simple all or nothing highlights) independencia (v2-2019) is for an improved implementation focusing on making highlights independent from eachother and other element nodes within the context DOM object. v2 uses data attributes as the source of truth about the text range selected to create the original highlight. This allows us freedom to manipulate the DOM at will and handle overlapping highlights a lot better. color string &lt;optional&gt; #ffff7b highlight color. excludeNodes Array.&lt;string&gt; &lt;optional&gt; [\"SCRIPT\",\"STYLE\"] Node types to exclude when calculating offsets and determining where to inject highlights. highlightedClass string &lt;optional&gt; highlighted class added to highlight, 'highlighted' by default. contextClass string &lt;optional&gt; highlighter-context class added to element to which highlighter is applied, 'highlighter-context' by default. useDefaultEvents boolean &lt;optional&gt; true Whether or not to use the default events to listen for text selections. The default events are \"mouseup\" and \"touchend\". Set this to false and register TextHiglighter.highlightHandler with your own events. It is down to you to remove the listener from your custom events when destroying instances of the text highlighter. normalizeElements boolean &lt;optional&gt; false Whether or not to normalise elements on the DOM when highlights are created, deserialised into the DOM, focused and deselected. Normalising events has a huge performance implication when enabling highlighting for a root element that contains thousands of nodes. This only applies for the independencia v2-2019 version. onRemoveHighlight function function called before highlight is removed. Highlight is passed as param. Function should return true if highlight should be removed, or false - to prevent removal. onBeforeHighlight function function called before highlight is created. Range object is passed as param. Function should return true to continue processing, or false - to prevent highlighting. preprocessDescriptors function function called when a user has made a selection to create a highlight, this is called before the highlight are loaded into the DOM. This should be used to carry out tasks like customising the span wrapper used to inject highlights with data attributes specific to your application. (This is only utilised by v2-2019 onwards) onAfterHighlight function function called after highlight is created. Array of created wrappers is passed as param. This is called once the highlights have been loaded into the DOM. (The callback interface differs between versions, see specific highlighter classes for more info) registerEventsOnConstruction boolean Whether or not to attempt to register events when the text highlighter is first instantiated. In the case options.useDefaultEvents is false, even with this enabled the events won't be registered, this is only relevant if you want more control and register events at a later point. Source: text-highlighter.js, line 79 Methods &lt;static&gt; createWrapper(options) Creates wrapper for highlights. TextHighlighter instance calls this method each time it needs to create highlights and pass options retrieved in constructor. Parameters: Name Type Description options object the same object as in TextHighlighter constructor. Source: text-highlighter.js, line 34 Returns: Type HTMLElement deserializeHighlights(json) Deserializes highlights. Parameters: Name Type Description json object JSON object with highlights definition. Source: text-highlighter.js, line 263 Throws: exception when can't parse JSON or JSON has invalid structure. Returns: array of deserialized highlights. Type Array destroy() Permanently disables highlighting. Unbinds events and remove context element class. Source: text-highlighter.js, line 127 find(text [, caseSensitive]) Finds and highlights given text. Parameters: Name Type Argument Description text string text to search for caseSensitive boolean &lt;optional&gt; if set to true, performs case sensitive search (default: true) Source: text-highlighter.js, line 273 focusUsingId(id, descriptors) Focuses a highlight, bringing it forward in the case it is sitting behind another overlapping highlight, or a highlight it is nested inside. This is only supported by independencia (v2-2019) and onwards. For older versions, this will simply do nothing. Parameters: Name Type Description id string The id of the highlight present in the class names of all elements in the DOM that represent the highlight. descriptors string Optional serialised descriptors, useful in the case a highlight has no representation in the DOM where empty highlight wrapper nodes are removed to use less dom elements. Source: text-highlighter.js, line 321 getColor() Returns highlighting color. Source: text-highlighter.js, line 200 Returns: Type string getHighlights(params) Returns highlights from given container. Parameters: Name Type Description params Properties Name Type Argument Description container HTMLElement &lt;optional&gt; return highlights from this element. Default: the element the highlighter is applied to. andSelf boolean &lt;optional&gt; if set to true and container is a highlight itself, add container to returned results. Default: true. grouped boolean &lt;optional&gt; if set to true, highlights are grouped in logical groups of highlights added in the same moment. Each group is an object which has got array of highlights, 'toString' method and 'timestamp' property. Default: false. Source: text-highlighter.js, line 229 Returns: array of highlights. Type Array highlightHandler() Listener to events that can trigger the creation of a highlight. By default this is triggered on \"mouseup\" and \"touchend\" events. If you disable the default events by setting options.useDefaultEvents you will need to register this handler with your own events and make sure you remove the listener when you destroy the instance of the TextHighlighter as well. Source: text-highlighter.js, line 153 highlightRange(range, wrapper) Highlights range. Wraps text of given range object in wrapper element. Parameters: Name Type Description range Range wrapper HTMLElement Source: text-highlighter.js, line 169 Returns: array of created highlights. Type Array isHighlight(el) Returns true if element is a highlight. All highlights have 'data-highlighted' attribute. Parameters: Name Type Description el element to check. Source: text-highlighter.js, line 240 Returns: Type boolean normalizeHighlights(highlights) Normalizes highlights. Ensure at least text nodes are normalized, carries out some flattening and nesting where necessary. Parameters: Name Type Description highlights Array highlights to normalize. Source: text-highlighter.js, line 182 Returns: array of normalized highlights. Order and number of returned highlights may be different than input highlights. Type Array registerDefaultEvents() Registers the default event listeners that trigger the proecss of creating a highlight. Source: text-highlighter.js, line 140 removeHighlights(element, id) Removes highlights from element. If element is a highlight itself, it is removed as well. If no element is given, all highlights all removed. Parameters: Name Type Description element HTMLElement element to remove highlights from. if empty, the root element of the highlighter will be used. id string The unique id of a highlight represented by a collection of elements. Source: text-highlighter.js, line 212 serializeHighlights(id) Serializes all highlights in the element the highlighter is applied to. the id is not used in the initial version of the highlighter. Parameters: Name Type Description id string The unique identifier grouping a set of highlight elements together. Source: text-highlighter.js, line 252 Returns: stringified JSON with highlights definition Type string setColor(color) Sets highlighting color. Parameters: Name Type Description color string valid CSS color. Source: text-highlighter.js, line 191 Type Definitions HighlightDescriptor Deselects a highlight, bringing any nested highlights in the list of descriptors forward. This is only supported by independencia (v2-2019) and onwards. For older versions, this will simply do nothing. Type: object Properties: Name Type Description id string serialisedDescriptor string Source: text-highlighter.js, line 333 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
