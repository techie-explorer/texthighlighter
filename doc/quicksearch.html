<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"utils_arrays.js.html":{"id":"utils_arrays.js.html","title":"Source: utils/arrays.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn Source: utils/arrays.js /** * Returns array without duplicated values. * @param {Array} arr * @returns {Array} */ export function unique(arr) { return arr.filter(function(value, idx, self) { return self.indexOf(value) === idx; }); } /** * Returns array of strings with all strings converted to lower case. * * @param {String[]} arr * @returns {String[]} */ export function arrayToLower(arr) { return arr.map(Function.prototype.call, String.prototype.toLowerCase); } × Search results Close "},"utils_highlights.js.html":{"id":"utils_highlights.js.html","title":"Source: utils/highlights.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn Source: utils/highlights.js import dom, { NODE_TYPE } from \"./dom\"; import { DATA_ATTR, START_OFFSET_ATTR, LENGTH_ATTR, TIMESTAMP_ATTR } from \"../config\"; import { arrayToLower } from \"./arrays\"; import { scaleFromTransformMatrix } from \"./transform\"; /** * Takes range object as parameter and refines it boundaries * @param range * @returns {object} refined boundaries and initial state of highlighting algorithm. */ export function refineRangeBoundaries(range) { let startContainer = range.startContainer, endContainer = range.endContainer, ancestor = range.commonAncestorContainer, goDeeper = true; if (range.endOffset === 0) { while ( !endContainer.previousSibling &amp;&amp; endContainer.parentNode !== ancestor ) { endContainer = endContainer.parentNode; } endContainer = endContainer.previousSibling; } else if (endContainer.nodeType === NODE_TYPE.TEXT_NODE) { if (range.endOffset &lt; endContainer.nodeValue.length) { endContainer.splitText(range.endOffset); } } else if (range.endOffset &gt; 0) { endContainer = endContainer.childNodes.item(range.endOffset - 1); } if (startContainer.nodeType === NODE_TYPE.TEXT_NODE) { if (range.startOffset === startContainer.nodeValue.length) { goDeeper = false; } else if (range.startOffset &gt; 0) { startContainer = startContainer.splitText(range.startOffset); if (endContainer === startContainer.previousSibling) { endContainer = startContainer; } } } else if (range.startOffset &lt; startContainer.childNodes.length) { startContainer = startContainer.childNodes.item(range.startOffset); } else { startContainer = startContainer.nextSibling; } return { startContainer: startContainer, endContainer: endContainer, goDeeper: goDeeper }; } /** * Sorts array of DOM elements by its depth in DOM tree. * @param {HTMLElement[]} arr - array to sort. * @param {boolean} descending - order of sort. */ export function sortByDepth(arr, descending) { arr.sort(function(a, b) { return ( dom(descending ? b : a).parents().length - dom(descending ? a : b).parents().length ); }); } /** * Returns true if elements a i b have the same color. * @param {Node} a * @param {Node} b * @returns {boolean} */ export function haveSameColor(a, b) { return dom(a).color() === dom(b).color(); } /** * Creates wrapper for highlights. * TextHighlighter instance calls this method each time it needs to create highlights and pass options retrieved * in constructor. * @param {object} options - the same object as in TextHighlighter constructor. * @returns {HTMLElement} */ export function createWrapper(options) { let span = document.createElement(\"span\"); span.style.backgroundColor = options.color; span.className = options.highlightedClass; return span; } export function findTextNodeAtLocation(element, locationInChildNodes) { console.log(\"Element as parameter: \", element); let textNodeElement = element; let i = 0; while (textNodeElement &amp;&amp; textNodeElement.nodeType !== NODE_TYPE.TEXT_NODE) { console.log(`textNodeElement step ${i}`, textNodeElement); if (locationInChildNodes === \"start\") { if (textNodeElement.childNodes.length &gt; 0) { textNodeElement = textNodeElement.childNodes[0]; } else { textNodeElement = textNodeElement.nextSibling; } } else if (locationInChildNodes === \"end\") { if (textNodeElement.childNodes.length &gt; 0) { let lastIndex = textNodeElement.childNodes.length - 1; textNodeElement = textNodeElement.childNodes[lastIndex]; } else { textNodeElement = textNodeElement.previousSibling; } } else { textNodeElement = null; } i++; } console.log(\"text node element returned: \", textNodeElement); return textNodeElement; } function textContentExcludingTags(node, excludeNodeNames) { return dom(node).textContentExcludingTags(arrayToLower(excludeNodeNames)); } /** * Determine where to inject a highlight based on it's offset. * A highlight can span multiple nodes, so in here we accumulate * all those nodes with offset and length of the content in the node * included in the highlight. * * @param {*} highlight * @param {*} parentNode */ export function findNodesAndOffsets( highlight, parentNode, excludeNodeNames = [\"SCRIPT\", \"STYLE\"] ) { const nodesAndOffsets = []; let currentNode = parentNode; let currentOffset = 0; const highlightEndOffset = highlight.offset + highlight.length; while (currentNode &amp;&amp; currentOffset &lt; highlightEndOffset) { // Ensure we ignore node types that the caller has specified should be excluded. if (!excludeNodeNames.includes(currentNode.nodeName)) { const textLength = textContentExcludingTags(currentNode, excludeNodeNames) .length; const endOfCurrentNodeOffset = currentOffset + textLength; if (endOfCurrentNodeOffset &gt; highlight.offset) { const isTerminalNode = currentNode.childNodes.length === 0; if (isTerminalNode) { if (currentNode.nodeType === NODE_TYPE.TEXT_NODE) { const offsetWithinNode = highlight.offset &gt; currentOffset ? highlight.offset - currentOffset : 0; const lengthInHighlight = highlightEndOffset &gt; endOfCurrentNodeOffset ? textLength - offsetWithinNode : highlightEndOffset - currentOffset - offsetWithinNode; nodesAndOffsets.push({ node: currentNode, offset: offsetWithinNode, length: lengthInHighlight }); currentOffset = endOfCurrentNodeOffset; } // It doesn't matter if it is a text node or not at this point, // we still need to get the next sibling of the node or it's ancestors. currentNode = dom(currentNode).nextClosestSibling(); } else { currentNode = currentNode.childNodes[0]; } } else { currentOffset = endOfCurrentNodeOffset; currentNode = currentNode.nextSibling; } } else { currentNode = dom(currentNode).nextClosestSibling(); } } return nodesAndOffsets; } export function getElementOffset( childElement, rootElement, excludeNodeNames = [\"SCRIPT\", \"STYLE\"] ) { let offset = 0; let childNodes; let currentElement = childElement; do { // Ensure specified node types are not counted in the offset. if (!excludeNodeNames.includes(currentElement.nodeName)) { childNodes = Array.prototype.slice.call( currentElement.parentNode.childNodes ); const childElementIndex = childNodes.indexOf(currentElement); const offsetInCurrentParent = getTextOffsetBefore( childNodes, childElementIndex, excludeNodeNames ); offset += offsetInCurrentParent; } currentElement = currentElement.parentNode; } while (currentElement !== rootElement || !currentElement); return offset; } function getTextOffsetBefore(childNodes, cutIndex, excludeNodeNames) { let textOffset = 0; for (let i = 0; i &lt; cutIndex; i++) { const currentNode = childNodes[i]; // Strip out all nodes from the child node that we should be excluding. // // Use textContent and not innerText to account for invisible characters such as carriage returns as well, // plus innerText forces a reflow of the layout and as we access text content of nodes // a lot in the highlighting process, we don't want to take the performance hit. // https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent const text = dom(currentNode).textContentExcludingTags( arrayToLower(excludeNodeNames) ); if ( !excludeNodeNames.includes(currentNode.nodeName) &amp;&amp; text &amp;&amp; text.length &gt; 0 ) { textOffset += text.length; } } return textOffset; } export function findFirstNonSharedParent(elements) { let childElement = elements.childElement; let otherElement = elements.otherElement; let parents = dom(childElement).parentsWithoutDocument(); let i = 0; let firstNonSharedParent = null; let allParentsAreShared = false; while (!firstNonSharedParent &amp;&amp; !allParentsAreShared &amp;&amp; i &lt; parents.length) { const currentParent = parents[i]; if (currentParent.contains(otherElement)) { console.log(\"currentParent contains other element!\", currentParent); if (i &gt; 0) { firstNonSharedParent = parents[i - 1]; } else { allParentsAreShared = true; } } i++; } return firstNonSharedParent; } const siblingRemovalDirections = { start: \"previousSibling\", end: \"nextSibling\" }; const siblingTextNodeMergeDirections = { start: \"nextSibling\", end: \"previousSibling\" }; function removeSiblingsInDirection(startNode, direction) { let sibling = startNode[direction]; while (sibling) { startNode.parentNode.removeChild(sibling); sibling = sibling[direction]; } } /** * Merges the text of all sibling text nodes with the start node. * * @param {HTMLElement} startNode * @param {string} direction */ function mergeSiblingTextNodesInDirection(startNode, direction) { let sibling = startNode[direction]; while (sibling) { if (sibling.nodeType === NODE_TYPE.TEXT_NODE) { startNode.textContent += sibling.textContent; startNode.parentNode.removeChild(sibling); sibling = sibling[direction]; } } } export function extractElementContentForHighlight(params) { let element = params.element; let elementAncestor = params.elementAncestor; let options = params.options; let locationInSelection = params.locationInSelection; let elementAncestorCopy = elementAncestor.cloneNode(true); // Beginning of childNodes list for end container in selection // and end of childNodes list for start container in selection. let locationInChildNodes = locationInSelection === \"start\" ? \"end\" : \"start\"; let elementCopy = findTextNodeAtLocation( elementAncestorCopy, locationInChildNodes ); let elementCopyParent = elementCopy.parentNode; removeSiblingsInDirection( elementCopy, siblingRemovalDirections[locationInSelection] ); mergeSiblingTextNodesInDirection( elementCopy, siblingTextNodeMergeDirections[locationInSelection] ); console.log(\"elementCopy: \", elementCopy); console.log(\"elementCopyParent: \", elementCopyParent); // Clean out any nested highlight wrappers. if ( elementCopyParent !== elementAncestorCopy &amp;&amp; elementCopyParent.classList.contains(options.highlightedClass) ) { dom(elementCopyParent).unwrap(); } // Remove the text node that we need for the new highlight // from the existing highlight or other element. element.parentNode.removeChild(element); return { elementAncestorCopy, elementCopy }; } function gatherSiblingsUpToEndNode(startNodeOrContainer, endNode) { const gatheredSiblings = []; let foundEndNodeSibling = false; let currentNode = startNodeOrContainer.nextSibling; while (currentNode &amp;&amp; !foundEndNodeSibling) { if (currentNode === endNode || currentNode.contains(endNode)) { foundEndNodeSibling = true; } else { gatheredSiblings.push(currentNode); currentNode = currentNode.nextSibling; } } return { gatheredSiblings, foundEndNodeSibling }; } /** * Gets all the nodes in between the provided start and end. * * @param {HTMLElement} startNode * @param {HTMLElement} endNode * @returns {HTMLElement[]} Nodes that live in between the two. */ export function nodesInBetween(startNode, endNode) { if (startNode === endNode) { return []; } // First attempt the easiest solution, hoping endNode will be at the same level // as the start node or contained in an element at the same level. const { foundEndNodeSibling: foundEndNodeSiblingOnSameLevel, gatheredSiblings } = gatherSiblingsUpToEndNode(startNode, endNode); if (foundEndNodeSiblingOnSameLevel) { return gatheredSiblings; } // Now go for the route that goes to the highest parent of the start node in the tree // that is not the parent of the end node. const startNodeParent = findFirstNonSharedParent({ childElement: startNode, otherElement: endNode }); if (startNodeParent) { const { foundEndNodeSibling: foundEndNodeSiblingFromParentLevel, gatheredSiblings: gatheredSiblingsFromParent } = gatherSiblingsUpToEndNode(startNodeParent, endNode); if (foundEndNodeSiblingFromParentLevel) { return gatheredSiblingsFromParent; } } return []; } /** * Groups given highlights by timestamp. * @param {Array} highlights * @param {string} timestampAttr * @returns {Array} Grouped highlights. */ export function groupHighlights(highlights, timestampAttr) { let order = [], chunks = {}, grouped = []; highlights.forEach(function(hl) { let timestamp = hl.getAttribute(timestampAttr); if (typeof chunks[timestamp] === \"undefined\") { chunks[timestamp] = []; order.push(timestamp); } chunks[timestamp].push(hl); }); order.forEach(function(timestamp) { let group = chunks[timestamp]; grouped.push({ chunks: group, timestamp: timestamp, toString: function() { return group .map(function(h) { return h.textContent; }) .join(\"\"); } }); }); return grouped; } export function retrieveHighlights(params) { params = { andSelf: true, grouped: false, ...params }; let nodeList = params.container.querySelectorAll(\"[\" + params.dataAttr + \"]\"), highlights = Array.prototype.slice.call(nodeList); if ( params.andSelf === true &amp;&amp; params.container.hasAttribute(params.dataAttr) ) { highlights.push(params.container); } if (params.grouped) { highlights = groupHighlights(highlights, params.timestampAttr); } return highlights; } export function isElementHighlight(el, dataAttr) { return ( el &amp;&amp; el.nodeType === NODE_TYPE.ELEMENT_NODE &amp;&amp; el.hasAttribute(dataAttr) ); } export function addNodesToHighlightAfterElement({ element, elementAncestor, highlightWrapper, highlightedClass }) { if (elementAncestor) { if (elementAncestor.classList.contains(highlightedClass)) { // Ensure we only take the children from a parent that is a highlight. elementAncestor.childNodes.forEach(childNode =&gt; { // if (dom(childNode).isAfter(element)) { // } elementAncestor.appendChild(childNode); }); } else { highlightWrapper.appendChild(elementAncestor); } } else { highlightWrapper.appendChild(element); } } /** * Collects the human-readable highlighted text for all nodes in the selected range. * * @param {Range} range * * @return {string} The human-readable highlighted text for the given range. */ export function getHighlightedTextForRange( range, excludeTags = [\"script\", \"style\"] ) { // Strip out all carriage returns and excess html layout space. return dom(range.cloneContents()) .textContentExcludingTags(arrayToLower(excludeTags)) .replace(/\\s{2,}/g, \" \") .replace(\"\\r\\n\", \"\") .replace(\"\\r\", \"\") .replace(\"\\n\", \"\"); } /** * Collects the human-readable highlighted text for all nodes from the start text offset * relative to the root element. * * @param {{ rootElement: HTMLElement, startOffset: number, length: number}} params * The root-relative parameters for extracting highlighted text. * * @return {string} The human-readable highlighted text for the given root element, offset and length. */ export function getHighlightedTextRelativeToRoot({ rootElement, startOffset, length, excludeTags = [\"script\", \"style\"] }) { const textContent = dom(rootElement).textContentExcludingTags( arrayToLower(excludeTags) ); const highlightedRawText = textContent.substring( startOffset, Number.parseInt(startOffset) + Number.parseInt(length) ); const textNode = document.createTextNode(highlightedRawText); const tempContainer = document.createElement(\"div\"); tempContainer.appendChild(textNode); // Extract the human-readable text only. return tempContainer.innerText; } export function createDescriptors({ rootElement, range, wrapper, excludeNodeNames = [\"SCRIPT\", \"STYLE\"] }) { const wrapperClone = wrapper.cloneNode(true); const startOffset = getElementOffset(range.startContainer, rootElement, excludeNodeNames) + range.startOffset; const endOffset = range.startContainer === range.endContainer ? startOffset + (range.endOffset - range.startOffset) : getElementOffset(range.endContainer, rootElement, excludeNodeNames) + range.endOffset; const length = endOffset - startOffset; wrapperClone.setAttribute(DATA_ATTR, true); wrapperClone.setAttribute(START_OFFSET_ATTR, startOffset); wrapperClone.setAttribute(LENGTH_ATTR, length); wrapperClone.innerHTML = \"\"; const wrapperHTML = wrapperClone.outerHTML; const descriptor = [ wrapperHTML, // retrieve all the text content between the start and end offsets. getHighlightedTextForRange(range, excludeNodeNames), startOffset, length ]; return [descriptor]; } /** * * * @param {HTMLElement} node The element we need to get parent information for. * @param {string} id The unique id of the collection of elements representing a highlight. * @param {HTMLElement} rootElement The root element of the context to stop at. * * @return {boolean} */ function isClosestHighlightParent(node, id, rootElement) { let isClosestHighlightParent = true; let currentNode = node.parentNode; while ( currentNode &amp;&amp; currentNode !== rootElement &amp;&amp; isClosestHighlightParent ) { if ( isElementHighlight(currentNode, DATA_ATTR) &amp;&amp; !currentNode.classList.contains(id) ) { // The case there is a closer parent than the highlight for the provided id. isClosestHighlightParent = false; } else { currentNode = currentNode.parentNode; } } return isClosestHighlightParent; } /** * Focuses a set of highlight elements for a given id by ensuring if it has descendants that are highlights * it is moved inside of the innermost highlight. * * The innermost highlight's styles will be applied and will be visible to the user * and given the \"focus\". * * To focus the red highlight the following: * * -- &lt;red-highlight&gt; * ---- &lt;blue-highlight&gt; * ------ &lt;green-highlight&gt; * ---------- Highlighted text * * becomes: * * -- &lt;blue-highlight&gt; * ---- &lt;green-highlight&gt; * ------ &lt;red-highlight&gt; * -------- Highlighted text * * and * * -- &lt;red-highlight&gt; * ---- Some text only highlighted in red * ---- &lt;blue-highlight&gt; * ------ Text in blue and red * ------ &lt;green-highlight&gt; * ---------- Rest of the highlight in red, green and blue * * becomes * * -- &lt;red-highlight&gt; * ---- Some text only highlighted in red * -- &lt;blue-highlight&gt; * ---- &lt;red-highlight-copy-1&gt; * ------ Text in blue and red * ---- &lt;green-highlight&gt; * ------ &lt;red-highlight-copy-2&gt; * -------- Rest of the highlight in red, green and blue * * @typedef NodeInfo * @type {object} * @property {HTMLElement} nodeInfo.node The html element (This will in most cases be a text node) * @property {number} nodeInfo.offset The offset within the node to be highlighted * @property {number} nodeInfo.length The length within the node that should be highlighted. * * @param {string} id The unique identifier of a highlight represented by one or more nodes in the DOM. * @param {NodeInfo[]} nodeInfoList The highlight portion node information that should be focused. * @param {HTMLElement} highlightWrapper The highlight wrapper representing the highlight to be focused. * * @param {HTMLElement} rootElement The root context element to normalise elements within. */ export function focusHighlightNodes( id, nodeInfoList, highlightWrapper, rootElement ) { nodeInfoList.forEach(nodeInfo =&gt; { const node = nodeInfo.node; // Only wrap the node if the closest highlight parent isn't one with the given id. if (!isClosestHighlightParent(node, id, rootElement)) { // Ensure any ancestors that aren't direct parents that represent the same highlight wrapper are removed. const ancestors = dom(node).parentsUpTo(rootElement); ancestors.forEach(ancestor =&gt; { if ( isElementHighlight(ancestor, DATA_ATTR) &amp;&amp; ancestor.classList.contains(id) ) { // Ensure a copy of the ancestor is wrapped back around any // other children that do not contain the current node. ancestor.childNodes.forEach(ancestorChild =&gt; { if (!ancestorChild.contains(node)) { const wrapper = highlightWrapper.cloneNode(true); dom(ancestorChild).wrap(wrapper); } }); dom(ancestor).unwrap(); } }); // Now wrap the node or the part of the node the highlight covers directly with the wrapper. let nodeToBeWrapped = node; if (nodeInfo.offset &gt; 0) { nodeToBeWrapped = node.splitText(nodeInfo.offset); } if (nodeInfo.length &lt; nodeToBeWrapped.textContent.length) { nodeToBeWrapped.splitText(nodeInfo.length); } dom(nodeToBeWrapped).wrap(highlightWrapper.cloneNode(true)); } }); // Ensure we normalise all nodes in the root container to merge sibling elements // of the same highlight together that get copied for the purpose of focusing. dom(rootElement).normalizeElements(); } × Search results Close "},"config.js.html":{"id":"config.js.html","title":"Source: config.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn Source: config.js /** * Attribute added by default to every highlight. * @type {string} */ export const DATA_ATTR = \"data-highlighted\"; /** * Attribute used to group highlight wrappers. * @type {string} */ export const TIMESTAMP_ATTR = \"data-timestamp\"; export const START_OFFSET_ATTR = \"data-start-offset\"; export const LENGTH_ATTR = \"data-length\"; /** * Don't highlight content of these tags. * @type {string[]} */ export const IGNORE_TAGS = [ \"SCRIPT\", \"STYLE\", \"SELECT\", \"OPTION\", \"BUTTON\", \"OBJECT\", \"APPLET\", \"VIDEO\", \"AUDIO\", \"CANVAS\", \"EMBED\", \"PARAM\", \"METER\", \"PROGRESS\" ]; × Search results Close "},"utils_dom.js.html":{"id":"utils_dom.js.html","title":"Source: utils/dom.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn Source: utils/dom.js import { isElementHighlight } from \"./highlights\"; export const NODE_TYPE = { ELEMENT_NODE: 1, TEXT_NODE: 3 }; /** * Utility functions to make DOM manipulation easier. * @param {Node|HTMLElement} [el] - base DOM element to manipulate * @returns {object} * */ const dom = function(el) { return /** @lends dom **/ { /** * Adds class to element. * @param {string} className */ addClass: function(className) { if (el.classList) { el.classList.add(className); } else { el.className += \" \" + className; } }, /** * Removes class from element. * @param {string} className */ removeClass: function(className) { if (el.classList) { el.classList.remove(className); } else { el.className = el.className.replace( new RegExp(\"(^|\\\\b)\" + className + \"(\\\\b|$)\", \"gi\"), \" \" ); } }, /** * Prepends child nodes to base element. * @param {Node[]} nodesToPrepend */ prepend: function(nodesToPrepend) { let nodes = Array.prototype.slice.call(nodesToPrepend), i = nodes.length; while (i--) { el.insertBefore(nodes[i], el.firstChild); } }, /** * Appends child nodes to base element. * @param {Node[]} nodesToAppend */ append: function(nodesToAppend) { let nodes = Array.prototype.slice.call(nodesToAppend); for (let i = 0, len = nodes.length; i &lt; len; ++i) { el.appendChild(nodes[i]); } }, /** * Inserts base element after refEl. * @param {Node} refEl - node after which base element will be inserted * @returns {Node} - inserted element */ insertAfter: function(refEl) { return refEl.parentNode.insertBefore(el, refEl.nextSibling); }, /** * Inserts base element before refEl. * @param {Node} refEl - node before which base element will be inserted * @returns {Node} - inserted element */ insertBefore: function(refEl) { return refEl.parentNode.insertBefore(el, refEl); }, /** * Removes base element from DOM. */ remove: function() { el.parentNode.removeChild(el); el = null; }, /** * Returns true if base element contains given child. * @param {Node|HTMLElement} child * @returns {boolean} */ contains: function(child) { return el !== child &amp;&amp; el.contains(child); }, /** * Wraps base element in wrapper element. * @param {HTMLElement} wrapper * @returns {HTMLElement} wrapper element */ wrap: function(wrapper) { if (el.parentNode) { el.parentNode.insertBefore(wrapper, el); } wrapper.appendChild(el); return wrapper; }, /** * Unwraps base element. * @returns {Node[]} - child nodes of unwrapped element. */ unwrap: function() { let nodes = Array.prototype.slice.call(el.childNodes), wrapper; nodes.forEach(function(node) { wrapper = node.parentNode; dom(node).insertBefore(node.parentNode); }); dom(wrapper).remove(); return nodes; }, /** * Returns array of base element parents. * @returns {HTMLElement[]} */ parents: function() { let parent, path = []; while ((parent = el.parentNode)) { path.push(parent); el = parent; } return path; }, /** * Returns array of base element parents up to the * provided root element. * * @param {HTMLElement} rootElement * @returns {HTMLElement[]} */ parentsUpTo: function(rootElement) { let parent, path = []; while ((parent = el.parentNode) &amp;&amp; parent !== rootElement) { path.push(parent); el = parent; } return path; }, /** * Returns array of base element parents, excluding the document. * @returns {HTMLElement[]} */ parentsWithoutDocument: function() { return this.parents().filter(elem =&gt; elem !== document); }, /** * Traverses up the tree to to get the next closest sibling of a node * or any of it's parents. * * This is used in scenarios where you have already consumed the parents while * traversing the tree but not the siblings of parents. * * @returns {HTMLElement | null} */ nextClosestSibling: function() { let current = el; let nextClosestSibling; do { nextClosestSibling = current.nextSibling; current = current.parentNode; } while (!nextClosestSibling &amp;&amp; current.parentNode); return nextClosestSibling; }, /** * Normalizes text nodes within base element, ie. merges sibling text nodes and assures that every * element node has only one text node. * It should does the same as standard element.normalize, but IE implements it incorrectly. */ normalizeTextNodes: function() { if (!el) { return; } if (el.nodeType === NODE_TYPE.TEXT_NODE) { while ( el.nextSibling &amp;&amp; el.nextSibling.nodeType === NODE_TYPE.TEXT_NODE ) { el.nodeValue += el.nextSibling.nodeValue; el.parentNode.removeChild(el.nextSibling); } } else { dom(el.firstChild).normalizeTextNodes(); } dom(el.nextSibling).normalizeTextNodes(); }, /** * Normalizes elements that have the a same id and are next to eachother in the child list */ normalizeElements: function() { if (!el) { return; } if (el.nodeType !== NODE_TYPE.TEXT_NODE) { if (isElementHighlight(el, \"data-highlighted\")) { let className = el.className; while ( className &amp;&amp; el.nextSibling &amp;&amp; el.nextSibling.nodeType !== NODE_TYPE.TEXT_NODE &amp;&amp; el.nextSibling.className === className ) { el.innerHTML += el.nextSibling.innerHTML; el.parentNode.removeChild(el.nextSibling); } dom(el.firstChild).normalizeElements(); } else { let id = el.id; while ( id &amp;&amp; el.nextSibling &amp;&amp; el.nextSibling.nodeType !== NODE_TYPE.TEXT_NODE &amp;&amp; el.nextSibling.id === id ) { el.innerHTML += el.nextSibling.innerHTML; el.parentNode.removeChild(el.nextSibling); } dom(el.firstChild).normalizeElements(); } } else { dom(el).normalizeTextNodes(); } dom(el.nextSibling).normalizeElements(); }, /** * Returns element background color. * @returns {CSSStyleDeclaration.backgroundColor} */ color: function() { return el.style.backgroundColor; }, /** * Creates dom element from given html string. * @param {string} html * @returns {NodeList} */ fromHTML: function(html) { let div = document.createElement(\"div\"); div.innerHTML = html; return div.childNodes; }, /** * Returns first range of the window of base element. * @returns {Range} */ getRange: function() { let selection = dom(el).getSelection(), range; if (selection.rangeCount &gt; 0) { range = selection.getRangeAt(0); } return range; }, /** * Removes all ranges of the window of base element. */ removeAllRanges: function() { let selection = dom(el).getSelection(); selection.removeAllRanges(); }, /** * Returns selection object of the window of base element. * @returns {Selection} */ getSelection: function() { return dom(el) .getWindow() .getSelection(); }, /** * Returns window of the base element. * @returns {Window} */ getWindow: function() { return dom(el).getDocument().defaultView; }, /** * Returns document of the base element. * @returns {HTMLDocument} */ getDocument: function() { // if ownerDocument is null then el is the document itself. return el.ownerDocument || el; }, /** * Returns whether the provided element comes after the base element. * * @param {HTMLElement} otherElement * * @returns {boolean} */ isAfter: function(otherElement, rootElement) { let sibling = el.nextSibling; let isAfter = false; while (sibling &amp;&amp; !isAfter) { if (sibling === otherElement) { isAfter = true; } else { if (!sibling.nextSibling) { sibling = el.parentNode.nextSibling; } else { sibling = sibling.nextSibling; } } } return isAfter; }, /** * Extracts all the text content for the root element excluding * all the text content inside any of the provided excluded tags. * * @param {string[]} excludeTags lement tags to exclude * * @returns {string} */ textContentExcludingTags: function(excludeTags) { // Ensure we simply return the text content in the case the element is a text node. if (el.nodeType !== NODE_TYPE.TEXT_NODE) { const elCopy = el.cloneNode(true); const elementsToBeExcluded = excludeTags.reduce((accum, tag) =&gt; { return [...accum, ...elCopy.querySelectorAll(tag)]; }, []); elementsToBeExcluded.forEach(toExcludeFromCopy =&gt; { toExcludeFromCopy.remove(); }); return elCopy.textContent; } return el.textContent; } }; }; export default dom; × Search results Close "},"jquery-plugin.js.html":{"id":"jquery-plugin.js.html","title":"Source: jquery-plugin.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn Source: jquery-plugin.js /* global jQuery TextHighlighter */ if (typeof jQuery !== \"undefined\") { (function($) { \"use strict\"; const PLUGIN_NAME = \"textHighlighter\"; function wrap(fn, wrapper) { return function() { wrapper.call(this, fn); }; } /** * The jQuery plugin namespace. * @external \"jQuery.fn\" * @see {@link http://docs.jquery.com/Plugins/Authoring The jQuery Plugin Guide} */ /** * Creates TextHighlighter instance and applies it to the given jQuery object. * @param {object} options Same as {@link TextHighlighter} options. * @returns {jQuery} * @example $('#sandbox').textHighlighter({ color: 'red' }); * @function external:\"jQuery.fn\".textHighlighter */ $.fn.textHighlighter = function(options) { return this.each(function() { let el = this, hl; if (!$.data(el, PLUGIN_NAME)) { hl = new TextHighlighter(el, options); hl.destroy = wrap(hl.destroy, function(destroy) { destroy.call(hl); $(el).removeData(PLUGIN_NAME); }); $.data(el, PLUGIN_NAME, hl); } }); }; $.fn.getHighlighter = function() { return this.data(PLUGIN_NAME); }; })(jQuery); } × Search results Close "},"global-script.js.html":{"id":"global-script.js.html","title":"Source: global-script.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn Source: global-script.js import TextHighlighter from \"./text-highlighter\"; /** * Expose the TextHighlighter class globally to be * used in demos and to be injected directly into html files. */ global.TextHighlighter = TextHighlighter; /** * Load the jquery plugin globally expecting jQuery and TextHighlighter to be globally * avaiable, this means this library doesn't need a hard requirement of jQuery. */ import \"./jquery-plugin\"; × Search results Close "},"highlighters_independencia.js.html":{"id":"highlighters_independencia.js.html","title":"Source: highlighters/independencia.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn Source: highlighters/independencia.js import { retrieveHighlights, isElementHighlight, sortByDepth, findNodesAndOffsets, createWrapper, createDescriptors, getHighlightedTextRelativeToRoot, focusHighlightNodes } from \"../utils/highlights\"; import { START_OFFSET_ATTR, LENGTH_ATTR, DATA_ATTR, TIMESTAMP_ATTR } from \"../config\"; import dom from \"../utils/dom\"; /** * IndependenciaHighlighter that provides text highlighting functionality to dom elements * with a focus on removing interdependence between highlights and other element nodes in the context element. * * @typedef {Object} HlDescriptor * @property {string} 0 - The span wrapper injected for the highlight. * @property {string} 1 - The highlighted text. * @property {number} 2 - The text offset relevant to the root element of a highlight. * @property {number} 3 - Length of highlight. * * @callback onAfterHighlightCallbackV2 * @param {Range} range * @param {HlDescriptor[]} highlightDescriptors * @param {number} timestamp * @return {HlDescriptor[]} */ class IndependenciaHighlighter { /** * Creates an IndependenciaHighlighter instance for functionality that focuses for highlight independence. * * @param {HTMLElement} element - DOM element to which highlighted will be applied. * @param {object} [options] - additional options. * @param {string} options.color - highlight color. * @param {string} options.excludeNodes - Node types to exclude when calculating offsets and determining where to inject highlights. * @param {string} options.highlightedClass - class added to highlight, 'highlighted' by default. * @param {string} options.contextClass - class added to element to which highlighter is applied, * 'highlighter-context' by default. * @param {function} options.onRemoveHighlight - function called before highlight is removed. Highlight is * passed as param. Function should return true if highlight should be removed, or false - to prevent removal. * @param {function} options.onBeforeHighlight - function called before highlight is created. Range object is * passed as param. Function should return true to continue processing, or false - to prevent highlighting. * @param {onAfterHighlightCallbackV2} options.onAfterHighlight - function called after highlight is created. Array of created * wrappers is passed as param. This should always return a set of descriptors. * @class IndependenciaHighlighter */ constructor(element, options) { this.el = element; this.options = options; } /** * Highlights current range. * @param {boolean} keepRange - Don't remove range after highlighting. Default: false. * @memberof IndependenciaHighlighter */ doHighlight(keepRange) { let range = dom(this.el).getRange(), wrapper, timestamp; if (!range || range.collapsed) { return; } if (this.options.onBeforeHighlight(range) === true) { timestamp = +new Date(); wrapper = createWrapper(this.options); wrapper.setAttribute(TIMESTAMP_ATTR, timestamp); const descriptors = createDescriptors({ rootElement: this.el, range, wrapper, excludeNodeNames: this.options.excludeNodes }); // createdHighlights = this.highlightRange(range, wrapper); // normalizedHighlights = this.normalizeHighlights(createdHighlights); const processedDescriptors = this.options.onAfterHighlight( range, descriptors, timestamp ); this.deserializeHighlights(JSON.stringify(processedDescriptors)); } if (!keepRange) { dom(this.el).removeAllRanges(); } } /** * Normalizes highlights. Ensures text nodes within any given element node are merged together, elements with the * same ID next to each other are merged together and highlights with the same ID next to each other are merged together. * * @returns {Array} - array of normalized highlights. Order and number of returned highlights may be different than * input highlights. * @memberof IndependenciaHighlighter */ normalizeHighlights() { dom(this.el).normalizeElements(); } /** * * Removes highlights from element. If element is a highlight itself, it is removed as well. * If no element is given, all highlights are removed. * @param {HTMLElement} element - element to remove highlights from * @param {string} id - The unique id of a highlight represented by a collection of elements. * @memberof IndependenciaHighlighter */ removeHighlights(element, id) { const container = element || this.el; let highlights = this.getHighlights({ container }), self = this; function removeHighlight(highlight) { dom(highlight).unwrap(); } highlights.forEach(function(hl) { if (!id || (id &amp;&amp; hl.classList.contains(id))) { if (self.options.onRemoveHighlight(hl) === true) { removeHighlight(hl); } } }); this.normalizeHighlights(highlights); } /** * Returns highlights from given container. * @param params * @param {HTMLElement} [params.container] - return highlights from this element. Default: the element the * highlighter is applied to. * @param {boolean} [params.andSelf] - if set to true and container is a highlight itself, add container to * returned results. Default: true. * @param {boolean} [params.grouped] - if set to true, highlights are grouped in logical groups of highlights added * in the same moment. Each group is an object which has got array of highlights, 'toString' method and 'timestamp' * property. Default: false. * @returns {Array} - array of highlights. * @memberof IndependenciaHighlighter */ getHighlights(params) { const mergedParams = { container: this.el, dataAttr: DATA_ATTR, timestampAttr: TIMESTAMP_ATTR, ...params }; return retrieveHighlights(mergedParams); } /** * Returns true if element is a highlight. * * @param el - element to check. * @returns {boolean} * @memberof IndependenciaHighlighter */ isHighlight(el, dataAttr) { return isElementHighlight(el, dataAttr); } /** * Serializes all highlights in the element the highlighter is applied to. * @returns {string} - stringified JSON with highlights definition * @memberof IndependenciaHighlighter */ serializeHighlights(id) { const highlights = this.getHighlights(), self = this; sortByDepth(highlights, false); if (highlights.length === 0) { return []; } // Even if there are multiple elements for a given highlight, the first // highlight in the DOM with the given ID in it's class name // will have all the information we need. const highlight = highlights.find(hl =&gt; hl.classList.contains(id)); if (!highlight) { return []; } const length = highlight.getAttribute(LENGTH_ATTR); const offset = highlight.getAttribute(START_OFFSET_ATTR); const wrapper = highlight.cloneNode(true); wrapper.innerHTML = \"\"; const wrapperHTML = wrapper.outerHTML; const descriptor = [ wrapperHTML, getHighlightedTextRelativeToRoot({ rootElement: self.el, startOffset: offset, length, excludeTags: this.options.excludeNodes }), offset, length ]; return JSON.stringify([descriptor]); } /** * Deserializes the independent form of highlights. * * @throws exception when can't parse JSON or JSON has invalid structure. * @param {object} json - JSON object with highlights definition. * @returns {Array} - array of deserialized highlights. * @memberof IndependenciaHighlighter */ deserializeHighlights(json) { let hlDescriptors, highlights = [], self = this; if (!json) { return highlights; } try { hlDescriptors = JSON.parse(json); } catch (e) { throw \"Can't parse JSON: \" + e; } function deserialise(hlDescriptor) { let hl = { wrapper: hlDescriptor[0], text: hlDescriptor[1], offset: Number.parseInt(hlDescriptor[2]), length: Number.parseInt(hlDescriptor[3]) }, hlNode, highlight; const parentNode = self.el; const highlightNodes = findNodesAndOffsets( hl, parentNode, self.options.excludeNodes ); highlightNodes.forEach( ({ node, offset: offsetWithinNode, length: lengthInNode }) =&gt; { // Don't call innerText to prevent DOM layout reflow. // Visible text content may be a bit of naive name but represents // everything excluding new lines and white space. const visibleTextContent = node.textContent .trim() .replace(/(\\r\\n|\\n|\\r)/gm, \"\"); if (visibleTextContent.length &gt; 0) { hlNode = node.splitText(offsetWithinNode); hlNode.splitText(lengthInNode); if (hlNode.nextSibling &amp;&amp; !hlNode.nextSibling.nodeValue) { dom(hlNode.nextSibling).remove(); } if (hlNode.previousSibling &amp;&amp; !hlNode.previousSibling.nodeValue) { dom(hlNode.previousSibling).remove(); } highlight = dom(hlNode).wrap(dom().fromHTML(hl.wrapper)[0]); highlights.push(highlight); } } ); } hlDescriptors.forEach(function(hlDescriptor) { try { deserialise(hlDescriptor); } catch (e) { if (console &amp;&amp; console.warn) { console.warn(\"Can't deserialize highlight descriptor. Cause: \" + e); } } }); // TODO: normalise at the end of deserialisation. // this.normalizeHighlights(highlights); // dom(this.el).normalizeElements(); return highlights; } /** * Focuses a highlight, bringing it forward in the case it is sitting behind another * overlapping highlight, or a highlight it is nested inside. * * @param {object} id - The id of the highlight present in the class names of all elements * in the DOM that represent the highlight. * * In order to utilise this functionality unique ids for highlights should be added to the class list in the highlight * wrapper within the descriptors. * You can do this in the onAfterHighlight callback when a highlight is first created. * * In the future it might be worth adding more flexiblity to allow for user-defined ways of storing ids to identify * elements in the DOM. (e.g. choosing between class name or data attributes) * * @param {string} descriptors - Optional serialised descriptors, useful in the case a highlight has no representation in the DOM * where empty highlight wrapper nodes are removed to use less dom elements. * * @memberof IndependenciaHighlighter */ focusUsingId(id, descriptors) { const highlightElements = this.el.querySelectorAll(`.${id}`); // For the future, we may save by accepting the offset and length as parameters as the caller should have this data // from the serialised descriptors. if (highlightElements.length &gt; 0) { const firstHighlightElement = highlightElements[0]; const nodesAndOffsets = findNodesAndOffsets( { offset: Number.parseInt( firstHighlightElement.getAttribute(START_OFFSET_ATTR) ), length: Number.parseInt( firstHighlightElement.getAttribute(LENGTH_ATTR) ) }, this.el, this.options.excludeNodes ); const highlightWrapper = firstHighlightElement.cloneNode(true); highlightWrapper.innerHTML = \"\"; focusHighlightNodes(id, nodesAndOffsets, highlightWrapper, this.el); } else if (descriptors) { // No elements in the DOM for the highlight? // let's deserialize the descriptor to bring the highlight into focus. this.deserializeHighlights(descriptors); } } /** * Deselects a highlight, bringing any nested highlights in the list of descriptors * forward. * * In order to utilise this functionality unique ids for highlights should be added to the class list in the highlight * wrapper within the descriptors. * You can do this in the onAfterHighlight callback when a highlight is first created. * * In the future it might be worth adding more flexiblity to allow for user-defined ways of storing ids to identify * elements in the DOM. (e.g. choosing between class name or data attributes) * * @typedef HighlightDescriptor * @type {object} * @property {string} id * @property {string} serialisedDescriptor * * @param {string} id The id of the deselected highlight. * @param {HighlightDescriptor[]} descriptors An array of serialised descriptors containing all the relevant highlights * that could be nested within the deselected highlight. * * @memberof IndependenciaHighlighter */ deselectUsingId(id, descriptors) { const deselectedHighlight = this.el.querySelector(`.${id}`); if (deselectedHighlight) { const deselectedStartOffset = Number.parseInt( deselectedHighlight.getAttribute(START_OFFSET_ATTR) ); const deselectedLength = Number.parseInt( deselectedHighlight.getAttribute(LENGTH_ATTR) ); const nestedDescriptors = descriptors .map(hlDescriptor =&gt; ({ id: hlDescriptor.id, descriptor: JSON.parse(hlDescriptor.serialisedDescriptor) })) .filter(hlDescriptor =&gt; { const innerDescriptor = hlDescriptor.descriptor[0]; const offset = Number.parseInt(innerDescriptor[2]); const length = Number.parseInt(innerDescriptor[3]); return ( offset &gt;= deselectedStartOffset &amp;&amp; offset + length &lt;= deselectedStartOffset + deselectedLength ); }); nestedDescriptors.sort((a, b) =&gt; { const aLength = Number.parseInt(a.descriptor[0][3]); const bLength = Number.parseInt(b.descriptor[0][3]); return aLength &gt; bLength ? -1 : 1; }); nestedDescriptors.forEach(hlDescriptor =&gt; { this.focusUsingId( hlDescriptor.id, JSON.stringify(hlDescriptor.descriptor) ); }); } } } export default IndependenciaHighlighter; × Search results Close "},"highlighters_primitivo.js.html":{"id":"highlighters_primitivo.js.html","title":"Source: highlighters/primitivo.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn Source: highlighters/primitivo.js import { refineRangeBoundaries, retrieveHighlights, isElementHighlight, sortByDepth, haveSameColor, createWrapper } from \"../utils/highlights\"; import dom, { NODE_TYPE } from \"../utils/dom\"; import { IGNORE_TAGS, DATA_ATTR, TIMESTAMP_ATTR } from \"../config\"; import { unique } from \"../utils/arrays\"; /** * PrimitivoHighlighter that provides text highlighting functionality to dom elements * for simple use cases. * * @callback onAfterHighlightCallbackV1 * @param {Range} range * @param {HTMLElement[]} highlights * @param {number} timestamp */ class PrimitivoHighlighter { /** * Creates a PrimitivoHighlighter instance for functionality specific to the original implementation. * * @param {HTMLElement} element - DOM element to which highlighted will be applied. * @param {object} [options] - additional options. * @param {string} options.color - highlight color. * @param {string} options.highlightedClass - class added to highlight, 'highlighted' by default. * @param {string} options.contextClass - class added to element to which highlighter is applied, * 'highlighter-context' by default. * @param {function} options.onRemoveHighlight - function called before highlight is removed. Highlight is * passed as param. Function should return true if highlight should be removed, or false - to prevent removal. * @param {function} options.onBeforeHighlight - function called before highlight is created. Range object is * passed as param. Function should return true to continue processing, or false - to prevent highlighting. * @param {onAfterHighlightCallbackV1} options.onAfterHighlight - function called after highlight is created. Array of created * wrappers is passed as param. * @class PrimitivoHighlighter */ constructor(element, options) { this.el = element; this.options = options; } /** * Highlights range. * Wraps text of given range object in wrapper element. * @param {Range} range * @param {HTMLElement} wrapper * @returns {Array} - array of created highlights. * @memberof PrimitivoHighlighter */ highlightRange(range, wrapper) { if (!range || range.collapsed) { return []; } console.log(\"ALSDebug28: range before refined! \", range); let result = refineRangeBoundaries(range), startContainer = result.startContainer, endContainer = result.endContainer, goDeeper = result.goDeeper, done = false, node = startContainer, highlights = [], highlight, wrapperClone, nodeParent; do { if (goDeeper &amp;&amp; node.nodeType === NODE_TYPE.TEXT_NODE) { if ( IGNORE_TAGS.indexOf(node.parentNode.tagName) === -1 &amp;&amp; node.nodeValue.trim() !== \"\" ) { wrapperClone = wrapper.cloneNode(true); wrapperClone.setAttribute(DATA_ATTR, true); nodeParent = node.parentNode; // highlight if a node is inside the el if (dom(this.el).contains(nodeParent) || nodeParent === this.el) { highlight = dom(node).wrap(wrapperClone); highlights.push(highlight); } } goDeeper = false; } if ( node === endContainer &amp;&amp; !(endContainer.hasChildNodes() &amp;&amp; goDeeper) ) { done = true; } if (node.tagName &amp;&amp; IGNORE_TAGS.indexOf(node.tagName) &gt; -1) { if (endContainer.parentNode === node) { done = true; } goDeeper = false; } if (goDeeper &amp;&amp; node.hasChildNodes()) { node = node.firstChild; } else if (node.nextSibling) { node = node.nextSibling; goDeeper = true; } else { node = node.parentNode; goDeeper = false; } } while (!done); return highlights; } /** * Normalizes highlights. Ensures that highlighting is done with use of the smallest possible number of * wrapping HTML elements. * Flattens highlights structure and merges sibling highlights. Normalizes text nodes within highlights. * @param {Array} highlights - highlights to normalize. * @returns {Array} - array of normalized highlights. Order and number of returned highlights may be different than * input highlights. * @memberof PrimitivoHighlighter */ normalizeHighlights(highlights) { var normalizedHighlights; this.flattenNestedHighlights(highlights); this.mergeSiblingHighlights(highlights); // omit removed nodes normalizedHighlights = highlights.filter(function(hl) { return hl.parentElement ? hl : null; }); normalizedHighlights = unique(normalizedHighlights); normalizedHighlights.sort(function(a, b) { return a.offsetTop - b.offsetTop || a.offsetLeft - b.offsetLeft; }); return normalizedHighlights; } /** * Flattens highlights structure. * Note: this method changes input highlights - their order and number after calling this method may change. * @param {Array} highlights - highlights to flatten. * @memberof PrimitivoHighlighter */ flattenNestedHighlights(highlights) { let again, self = this; sortByDepth(highlights, true); function flattenOnce() { let again = false; highlights.forEach(function(hl, i) { let parent = hl.parentElement, parentPrev = parent.previousSibling, parentNext = parent.nextSibling; if (self.isHighlight(parent, DATA_ATTR)) { if (!haveSameColor(parent, hl)) { if (!hl.nextSibling) { if (!parentNext) { dom(hl).insertAfter(parent); } else { dom(hl).insertBefore(parentNext); } dom(hl).insertBefore(parentNext || parent); again = true; } if (!hl.previousSibling) { if (!parentPrev) { dom(hl).insertBefore(parent); } else { dom(hl).insertAfter(parentPrev); } dom(hl).insertAfter(parentPrev || parent); again = true; } if ( hl.previousSibling &amp;&amp; hl.previousSibling.nodeType == 3 &amp;&amp; hl.nextSibling &amp;&amp; hl.nextSibling.nodeType == 3 ) { let spanleft = document.createElement(\"span\"); spanleft.style.backgroundColor = parent.style.backgroundColor; spanleft.className = parent.className; let timestamp = parent.attributes[TIMESTAMP_ATTR].nodeValue; spanleft.setAttribute(TIMESTAMP_ATTR, timestamp); spanleft.setAttribute(DATA_ATTR, true); let spanright = spanleft.cloneNode(true); dom(hl.previousSibling).wrap(spanleft); dom(hl.nextSibling).wrap(spanright); let nodes = Array.prototype.slice.call(parent.childNodes); nodes.forEach(function(node) { dom(node).insertBefore(node.parentNode); }); again = true; } if (!parent.hasChildNodes()) { dom(parent).remove(); } } else { parent.replaceChild(hl.firstChild, hl); highlights[i] = parent; again = true; } } }); return again; } do { again = flattenOnce(); } while (again); } /** * Merges sibling highlights and normalizes descendant text nodes. * Note: this method changes input highlights - their order and number after calling this method may change. * @param highlights * @memberof PrimitivoHighlighter */ mergeSiblingHighlights(highlights) { var self = this; function shouldMerge(current, node) { return ( node &amp;&amp; node.nodeType === NODE_TYPE.ELEMENT_NODE &amp;&amp; haveSameColor(current, node) &amp;&amp; self.isHighlight(node, DATA_ATTR) ); } highlights.forEach(function(highlight) { var prev = highlight.previousSibling, next = highlight.nextSibling; if (shouldMerge(highlight, prev)) { dom(highlight).prepend(prev.childNodes); dom(prev).remove(); } if (shouldMerge(highlight, next)) { dom(highlight).append(next.childNodes); dom(next).remove(); } dom(highlight).normalizeTextNodes(); }); } /** * Highlights current range. * @param {boolean} keepRange - Don't remove range after highlighting. Default: false. * @memberof PrimitivoHighlighter */ doHighlight(keepRange) { let range = dom(this.el).getRange(), wrapper, createdHighlights, normalizedHighlights, timestamp; if (!range || range.collapsed) { return; } if (this.options.onBeforeHighlight(range) === true) { timestamp = +new Date(); wrapper = createWrapper(this.options); wrapper.setAttribute(TIMESTAMP_ATTR, timestamp); createdHighlights = this.highlightRange(range, wrapper); normalizedHighlights = this.normalizeHighlights(createdHighlights); if (!this.options.onAfterHighlight) { console.log( \"ALSDEbug24: Primitivo: this.options: \", this.options, \"\\n\\n\\n\\n\" ); } this.options.onAfterHighlight(range, normalizedHighlights, timestamp); } if (!keepRange) { dom(this.el).removeAllRanges(); } } /** * Removes highlights from element. If element is a highlight itself, it is removed as well. * If no element is given, all highlights all removed. * @param {HTMLElement} [element] - element to remove highlights from * @memberof PrimitivoHighlighter */ removeHighlights(element) { var container = element || this.el, highlights = this.getHighlights({ container: container }), self = this; function mergeSiblingTextNodes(textNode) { var prev = textNode.previousSibling, next = textNode.nextSibling; if (prev &amp;&amp; prev.nodeType === NODE_TYPE.TEXT_NODE) { textNode.nodeValue = prev.nodeValue + textNode.nodeValue; dom(prev).remove(); } if (next &amp;&amp; next.nodeType === NODE_TYPE.TEXT_NODE) { textNode.nodeValue = textNode.nodeValue + next.nodeValue; dom(next).remove(); } } function removeHighlight(highlight) { var textNodes = dom(highlight).unwrap(); textNodes.forEach(function(node) { mergeSiblingTextNodes(node); }); } sortByDepth(highlights, true); highlights.forEach(function(hl) { if (self.options.onRemoveHighlight(hl) === true) { removeHighlight(hl); } }); } /** * Returns highlights from given container. * @param params * @param {HTMLElement} [params.container] - return highlights from this element. Default: the element the * highlighter is applied to. * @param {boolean} [params.andSelf] - if set to true and container is a highlight itself, add container to * returned results. Default: true. * @param {boolean} [params.grouped] - if set to true, highlights are grouped in logical groups of highlights added * in the same moment. Each group is an object which has got array of highlights, 'toString' method and 'timestamp' * property. Default: false. * @returns {Array} - array of highlights. * @memberof PrimitivoHighlighter */ getHighlights(params) { const mergedParams = { container: this.el, dataAttr: DATA_ATTR, timestampAttr: TIMESTAMP_ATTR, ...params }; return retrieveHighlights(mergedParams); } /** * Returns true if element is a highlight. * * @param el - element to check. * @returns {boolean} * @memberof PrimitivoHighlighter */ isHighlight(el, dataAttr) { return isElementHighlight(el, dataAttr); } /** * Serializes all highlights in the element the highlighter is applied to. * @returns {string} - stringified JSON with highlights definition * @memberof PrimitivoHighlighter */ serializeHighlights() { let highlights = this.getHighlights(), refEl = this.el, hlDescriptors = []; function getElementPath(el, refElement) { let path = [], childNodes; do { childNodes = Array.prototype.slice.call(el.parentNode.childNodes); path.unshift(childNodes.indexOf(el)); el = el.parentNode; } while (el !== refElement || !el); return path; } sortByDepth(highlights, false); highlights.forEach(function(highlight) { let offset = 0, // Hl offset from previous sibling within parent node. length = highlight.textContent.length, hlPath = getElementPath(highlight, refEl), wrapper = highlight.cloneNode(true); wrapper.innerHTML = \"\"; wrapper = wrapper.outerHTML; if ( highlight.previousSibling &amp;&amp; highlight.previousSibling.nodeType === NODE_TYPE.TEXT_NODE ) { offset = highlight.previousSibling.length; } hlDescriptors.push([ wrapper, highlight.textContent, hlPath.join(\":\"), offset, length ]); }); return JSON.stringify(hlDescriptors); } /** * Deserializes highlights. * @throws exception when can't parse JSON or JSON has invalid structure. * @param {object} json - JSON object with highlights definition. * @returns {Array} - array of deserialized highlights. * @memberof PrimitivoHighlighter */ deserializeHighlights(json) { let hlDescriptors, highlights = [], self = this; if (!json) { return highlights; } try { hlDescriptors = JSON.parse(json); } catch (e) { throw \"Can't parse JSON: \" + e; } function deserializationFn(hlDescriptor) { let hl = { wrapper: hlDescriptor[0], text: hlDescriptor[1], path: hlDescriptor[2].split(\":\"), offset: hlDescriptor[3], length: hlDescriptor[4] }, elIndex = hl.path.pop(), node = self.el, hlNode, highlight, idx; while ((idx = hl.path.shift())) { node = node.childNodes[idx]; } if ( node.childNodes[elIndex - 1] &amp;&amp; node.childNodes[elIndex - 1].nodeType === NODE_TYPE.TEXT_NODE ) { elIndex -= 1; } node = node.childNodes[elIndex]; hlNode = node.splitText(hl.offset); hlNode.splitText(hl.length); if (hlNode.nextSibling &amp;&amp; !hlNode.nextSibling.nodeValue) { dom(hlNode.nextSibling).remove(); } if (hlNode.previousSibling &amp;&amp; !hlNode.previousSibling.nodeValue) { dom(hlNode.previousSibling).remove(); } highlight = dom(hlNode).wrap(dom().fromHTML(hl.wrapper)[0]); highlights.push(highlight); } hlDescriptors.forEach(function(hlDescriptor) { try { deserializationFn(hlDescriptor); } catch (e) { if (console &amp;&amp; console.warn) { console.warn(\"Can't deserialize highlight descriptor. Cause: \" + e); } } }); return highlights; } } export default PrimitivoHighlighter; × Search results Close "},"utils_transform.js.html":{"id":"utils_transform.js.html","title":"Source: utils/transform.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn Source: utils/transform.js /** * Extracts the scale from a 2D transform matrix. * * @param {string} transformMatrix The 2D transform matrix. * * @return {number} The combined scale element of the transform. */ export function scaleFromTransformMatrix(transformMatrix) { const matrixValues = transformMatrix .split(\"(\")[1] .split(\"(\")[0] .split(\",\"); const a = matrixValues[0]; const b = matrixValues[1]; return Math.sqrt(a * a + b * b); } × Search results Close "},"text-highlighter.js.html":{"id":"text-highlighter.js.html","title":"Source: text-highlighter.js","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn Source: text-highlighter.js import dom from \"./utils/dom\"; import { bindEvents, unbindEvents } from \"./utils/events\"; import Primitivo from \"./highlighters/primitivo\"; import Independencia from \"./highlighters/independencia\"; import { DATA_ATTR } from \"./config\"; import { createWrapper } from \"./utils/highlights\"; const highlighters = { primitivo: Primitivo, \"v1-2014\": Primitivo, independencia: Independencia, \"v2-2019\": Independencia }; const versionNames = { \"v1-2014\": \"Primitivo (v1-2014)\", primitivo: \"Primitivo (v1-2014)\", \"v2-2019\": \"Independencia (v2-2019)\", independencia: \"Independencia (v2-2019)\" }; /** * TextHighlighter that provides text highlighting functionality to dom elements. */ class TextHighlighter { /** * Creates wrapper for highlights. * TextHighlighter instance calls this method each time it needs to create highlights and pass options retrieved * in constructor. * * @param {object} options - the same object as in TextHighlighter constructor. * @returns {HTMLElement} */ static createWrapper(options) { return createWrapper(options); } /** * Creates TextHighlighter instance and binds to given DOM elements. * * @param {HTMLElement} element - DOM element to which highlighted will be applied. * @param {object} [options] - additional options. * @param {string} options.version - The version of the text highlighting functionality to use. * There are two options: * primitivo (v1-2014) is for the initial implementation using interdependent highlight locators. * (Lots of issues for requirements beyond simple all or nothing highlights) * * independencia (v2-2019) is for an improved implementation focusing on making highlights independent * from eachother and other element nodes within the context DOM object. v2 uses data attributes * as the source of truth about the text range selected to create the original highlight. * This allows us freedom to manipulate the DOM at will and handle overlapping highlights a lot better. * * @param {string} options.color - highlight color. * @param {string} options.excludeNodes - Node types to exclude when calculating offsets and determining where to inject highlights. * @param {string} options.highlightedClass - class added to highlight, 'highlighted' by default. * @param {string} options.contextClass - class added to element to which highlighter is applied, * 'highlighter-context' by default. * @param {function} options.onRemoveHighlight - function called before highlight is removed. Highlight is * passed as param. Function should return true if highlight should be removed, or false - to prevent removal. * @param {function} options.onBeforeHighlight - function called before highlight is created. Range object is * passed as param. Function should return true to continue processing, or false - to prevent highlighting. * @param {function} options.onAfterHighlight - function called after highlight is created. Array of created * wrappers is passed as param. (The callback interface differs between versions, see specific highlighter classes for more info) * @class TextHighlighter */ constructor(element, options) { if (!element) { throw new Error(\"Missing anchor element\"); } this.el = element; this.options = { color: \"#ffff7b\", highlightedClass: \"highlighted\", contextClass: \"highlighter-context\", version: \"independencia\", excludeNodes: [\"SCRIPT\", \"STYLE\"], onRemoveHighlight: function() { return true; }, onBeforeHighlight: function() { return true; }, onAfterHighlight: function(_, hlts) { // For the newer version of the highlighter, we need to return the // highlight descriptors parameter by default in order to create highlights in the DOM. return hlts; }, ...options }; if (!highlighters[this.options.version]) { throw new Error( \"Please provide a valid version of the text highlighting functionality\" ); } this.highlighter = new highlighters[this.options.version]( this.el, this.options ); dom(this.el).addClass(this.options.contextClass); bindEvents(this.el, this); } /** * Permanently disables highlighting. * Unbinds events and remove context element class. * @memberof TextHighlighter */ destroy() { unbindEvents(this.el, this); dom(this.el).removeClass(this.options.contextClass); } highlightHandler() { this.doHighlight(); } doHighlight(keepRange) { this.highlighter.doHighlight(keepRange); } /** * Highlights range. * Wraps text of given range object in wrapper element. * @param {Range} range * @param {HTMLElement} wrapper * @returns {Array} - array of created highlights. * @memberof TextHighlighter */ highlightRange(range, wrapper) { return this.highlighter.highlightRange(range, wrapper); } /** * Normalizes highlights. Ensure at least text nodes are normalized, carries out some flattening and nesting * where necessary. * * @param {Array} highlights - highlights to normalize. * @returns {Array} - array of normalized highlights. Order and number of returned highlights may be different than * input highlights. * @memberof TextHighlighter */ normalizeHighlights(highlights) { return this.highlighter.normalizeHighlights(highlights); } /** * Sets highlighting color. * @param {string} color - valid CSS color. * @memberof TextHighlighter */ setColor(color) { this.options.color = color; } /** * Returns highlighting color. * @returns {string} * @memberof TextHighlighter */ getColor() { return this.options.color; } /** * Removes highlights from element. If element is a highlight itself, it is removed as well. * If no element is given, all highlights all removed. * @param {HTMLElement} element - element to remove highlights from. * if empty, the root element of the highlighter will be used. * @param {string} id - The unique id of a highlight represented by a collection of elements. * @memberof TextHighlighter */ removeHighlights(element, id) { this.highlighter.removeHighlights(element, id); } /** * Returns highlights from given container. * @param params * @param {HTMLElement} [params.container] - return highlights from this element. Default: the element the * highlighter is applied to. * @param {boolean} [params.andSelf] - if set to true and container is a highlight itself, add container to * returned results. Default: true. * @param {boolean} [params.grouped] - if set to true, highlights are grouped in logical groups of highlights added * in the same moment. Each group is an object which has got array of highlights, 'toString' method and 'timestamp' * property. Default: false. * @returns {Array} - array of highlights. * @memberof TextHighlighter */ getHighlights(params) { return this.highlighter.getHighlights(params); } /** * Returns true if element is a highlight. * All highlights have 'data-highlighted' attribute. * @param el - element to check. * @returns {boolean} * @memberof TextHighlighter */ isHighlight(el) { return this.highlighter.isHighlight(el, DATA_ATTR); } /** * Serializes all highlights in the element the highlighter is applied to. * the id is not used in the initial version of the highlighter. * * @param {string} id - The unique identifier grouping a set of highlight elements together. * @returns {string} - stringified JSON with highlights definition * @memberof TextHighlighter */ serializeHighlights(id) { return this.highlighter.serializeHighlights(id); } /** * Deserializes highlights. * @throws exception when can't parse JSON or JSON has invalid structure. * @param {object} json - JSON object with highlights definition. * @returns {Array} - array of deserialized highlights. * @memberof TextHighlighter */ deserializeHighlights(json) { return this.highlighter.deserializeHighlights(json); } /** * Finds and highlights given text. * @param {string} text - text to search for * @param {boolean} [caseSensitive] - if set to true, performs case sensitive search (default: true) * @memberof TextHighlighter */ find(text, caseSensitive) { let wnd = dom(this.el).getWindow(), scrollX = wnd.scrollX, scrollY = wnd.scrollY, caseSens = typeof caseSensitive === \"undefined\" ? true : caseSensitive; dom(this.el).removeAllRanges(); if (wnd.find) { while (wnd.find(text, caseSens)) { this.doHighlight(true); } } else if (wnd.document.body.createTextRange) { let textRange = wnd.document.body.createTextRange(); textRange.moveToElementText(this.el); while (textRange.findText(text, 1, caseSens ? 4 : 0)) { if ( !dom(this.el).contains(textRange.parentElement()) &amp;&amp; textRange.parentElement() !== this.el ) { break; } textRange.select(); this.doHighlight(true); textRange.collapse(false); } } dom(this.el).removeAllRanges(); wnd.scrollTo(scrollX, scrollY); } /** * Focuses a highlight, bringing it forward in the case it is sitting behind another * overlapping highlight, or a highlight it is nested inside. * * This is only supported by independencia (v2-2019) and onwards. * For older versions, this will simply do nothing. * * @param {string} id - The id of the highlight present in the class names of all elements * in the DOM that represent the highlight. * * @param {string} descriptors - Optional serialised descriptors, useful in the case a highlight has no representation in the DOM * where empty highlight wrapper nodes are removed to use less dom elements. * * @memberof TextHighlighter */ focusUsingId(id, descriptors) { if (this.highlighter.focusUsingId) { this.highlighter.focusUsingId(id, descriptors); } else { console.warn( `The ${ versionNames[this.options.version] } version of the text highlighter does not support focusing highlights.` ); } } /** * Deselects a highlight, bringing any nested highlights in the list of descriptors * forward. * * This is only supported by independencia (v2-2019) and onwards. * For older versions, this will simply do nothing. * * @typedef HighlightDescriptor * @type {object} * @property {string} id * @property {string} serialisedDescriptor * * @param {string} id The id of the deselected highlight. * @param {HighlightDescriptor[]} descriptors the serialised highlight descriptors for a set of highlights that could be nested * in the deselected highlight. * @memberof TextHighlighter */ deselectUsingId(id, descriptors) { if (this.highlighter.deselectUsingId) { this.highlighter.deselectUsingId(id, descriptors); } else { console.warn( `The ${ versionNames[this.options.version] } version of the text highlighter does not support deselecting highlights.` ); } } } export default TextHighlighter; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn Global Members &lt;constant&gt; DATA_ATTR :string Attribute added by default to every highlight. Type: string Source: config.js, line 5 &lt;constant&gt; IGNORE_TAGS :Array.&lt;string&gt; Don't highlight content of these tags. Type: Array.&lt;string&gt; Source: config.js, line 20 &lt;constant&gt; TIMESTAMP_ATTR :string Attribute used to group highlight wrappers. Type: string Source: config.js, line 11 Methods arrayToLower(arr) Returns array of strings with all strings converted to lower case. Parameters: Name Type Description arr Array.&lt;String&gt; Source: utils/arrays.js, line 18 Returns: Type Array.&lt;String&gt; createWrapper(options) Creates wrapper for highlights. TextHighlighter instance calls this method each time it needs to create highlights and pass options retrieved in constructor. Parameters: Name Type Description options object the same object as in TextHighlighter constructor. Source: utils/highlights.js, line 91 Returns: Type HTMLElement dom( [el]) Utility functions to make DOM manipulation easier. Parameters: Name Type Argument Description el Node | HTMLElement &lt;optional&gt; base DOM element to manipulate Source: utils/dom.js, line 10 Returns: Type object findNodesAndOffsets(highlight, parentNode) Determine where to inject a highlight based on it's offset. A highlight can span multiple nodes, so in here we accumulate all those nodes with offset and length of the content in the node included in the highlight. Parameters: Name Type Description highlight * parentNode * Source: utils/highlights.js, line 140 getHighlightedTextForRange(range) Collects the human-readable highlighted text for all nodes in the selected range. Parameters: Name Type Description range Range Source: utils/highlights.js, line 519 Returns: The human-readable highlighted text for the given range. Type string getHighlightedTextRelativeToRoot(params) Collects the human-readable highlighted text for all nodes from the start text offset relative to the root element. Parameters: Name Type Description params Object The root-relative parameters for extracting highlighted text. Source: utils/highlights.js, line 541 Returns: The human-readable highlighted text for the given root element, offset and length. Type string groupHighlights(highlights, timestampAttr) Groups given highlights by timestamp. Parameters: Name Type Description highlights Array timestampAttr string Source: utils/highlights.js, line 425 Returns: Grouped highlights. Type Array haveSameColor(a, b) Returns true if elements a i b have the same color. Parameters: Name Type Description a Node b Node Source: utils/highlights.js, line 80 Returns: Type boolean isClosestHighlightParent(node, id, rootElement) Parameters: Name Type Description node HTMLElement The element we need to get parent information for. id string The unique id of the collection of elements representing a highlight. rootElement HTMLElement The root element of the context to stop at. Source: utils/highlights.js, line 608 Returns: Type boolean mergeSiblingTextNodesInDirection(startNode, direction) Merges the text of all sibling text nodes with the start node. Parameters: Name Type Description startNode HTMLElement direction string Source: utils/highlights.js, line 303 nodesInBetween(startNode, endNode) Gets all the nodes in between the provided start and end. Parameters: Name Type Description startNode HTMLElement endNode HTMLElement Source: utils/highlights.js, line 383 Returns: Nodes that live in between the two. Type Array.&lt;HTMLElement&gt; refineRangeBoundaries(range) Takes range object as parameter and refines it boundaries Parameters: Name Type Description range Source: utils/highlights.js, line 16 Returns: refined boundaries and initial state of highlighting algorithm. Type object scaleFromTransformMatrix(transformMatrix) Extracts the scale from a 2D transform matrix. Parameters: Name Type Description transformMatrix string The 2D transform matrix. Source: utils/transform.js, line 8 Returns: The combined scale element of the transform. Type number sortByDepth(arr, descending) Sorts array of DOM elements by its depth in DOM tree. Parameters: Name Type Description arr Array.&lt;HTMLElement&gt; array to sort. descending boolean order of sort. Source: utils/highlights.js, line 65 unique(arr) Returns array without duplicated values. Parameters: Name Type Description arr Array Source: utils/arrays.js, line 6 Returns: Type Array Type Definitions NodeInfo Focuses a set of highlight elements for a given id by ensuring if it has descendants that are highlights it is moved inside of the innermost highlight. The innermost highlight's styles will be applied and will be visible to the user and given the \"focus\". To focus the red highlight the following: -- ---- ------ ---------- Highlighted text becomes: -- ---- ------ -------- Highlighted text and -- ---- Some text only highlighted in red ---- ------ Text in blue and red ------ ---------- Rest of the highlight in red, green and blue becomes -- ---- Some text only highlighted in red -- ---- ------ Text in blue and red ---- ------ -------- Rest of the highlight in red, green and blue Type: object Properties: Name Type Description nodeInfo.node HTMLElement The html element (This will in most cases be a text node) nodeInfo.offset number The offset within the node to be highlighted nodeInfo.length number The length within the node that should be highlighted. Source: utils/highlights.js, line 631 onAfterHighlightCallbackV1(range, highlights, timestamp) PrimitivoHighlighter that provides text highlighting functionality to dom elements for simple use cases. Parameters: Name Type Description range Range highlights Array.&lt;HTMLElement&gt; timestamp number Source: highlighters/primitivo.js, line 13 onAfterHighlightCallbackV2(range, highlightDescriptors, timestamp) IndependenciaHighlighter that provides text highlighting functionality to dom elements with a focus on removing interdependence between highlights and other element nodes in the context element. Parameters: Name Type Description range Range highlightDescriptors Array.&lt;HlDescriptor&gt; timestamp number Properties: Name Type Description 0 string The span wrapper injected for the highlight. 1 string The highlighted text. 2 number The text offset relevant to the root element of a highlight. 3 number Length of highlight. Source: highlighters/independencia.js, line 19 Returns: Type Array.&lt;HlDescriptor&gt; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn Classes Classes IndependenciaHighlighter PrimitivoHighlighter TextHighlighter TextHighlighter × Search results Close "},"externals.list.html":{"id":"externals.list.html","title":"Externals","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn Externals Classes IndependenciaHighlighter PrimitivoHighlighter TextHighlighter TextHighlighter × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn TextHighlighter TextHighlighter allows you to highlight text on web pages. Just select it! Getting started Using the library as an npm package Install the library by running: $ npm install text-highlighter Then you can use it like so: import TextHighlighter from 'text-highlighter'; // Example using a React ref if you are building a react application. const highlighter = new TextHighlighter(sandboxRef.current); // Example using an element accessed directly from the DOM. const highlighter = new TextHighlighter(document.getElementById(\"sandbox\")); Using the library as a script file Clone down this repository, checkout to the release tag representing the version you would like to use. (2.x.x + only, this won't work for 1.x.x, please refer to the documentation provided with 1.x.x releases) Ensure grunt is installed globally: npm install -g grunt Build the minified version of the library using the following command: grunt build Copy the script file from build/prod/TextHighlighter.min.js to the head section of your web page: &lt;script type=\"text/javascript\" src=\"TextHighlighter.min.js\"&gt;&lt;/script&gt; And use it! var hltr = new TextHighlighter(document.body); Features Highlighting of selected text. Highlighting all occurrences of given text (find &amp; highlight). Removing highlights. Selecting highlight color. Serialization &amp; deserialization. Focusing &amp; deselecting overlapping highlights. Works well in iframes. Keeps DOM clean. No dependencies. No jQuery or other libraries needed. Compatibility Should work in all decent browsers and IE 11. Running the tests First run npm install from the root directory of the repo to install all the test runner dependencies. Integration tests The integration tests covers the integration of the larger components that make up the highlighting functionality such as serialisation + deserialisation, focusing, deselecting, normalisation and interaction with callbacks. To run the integration tests use the following command: npm run test:integration Unit tests The unit tests cover functions that make up the smaller components that query, manipulate the DOM along with pure utility pieces. To run the unit tests use the following command: npm run test:unit Running the Primitivo tests (The first version of the highlighter) The first version of the highlighter contains tests in a standalone jasmine runner that runs in the browser. To run those tests, first set up the server: node testserver.js Then go to http://localhost:5002/test/test.html and the tests will run on page load. Building the API reference documentation Ensure all dev dependencies are installed using: npm install Ensure grunt is installed globally: npm install -g grunt To build the documentation, run the following command: grunt jsdoc Ensure the test server is running: node testserver.js Then go to http://localhost:5002/doc to see the API reference for the library. Demos Simple demo Callbacks Serialization Iframe Documentation You may check API reference or Wiki pages on GitHub. × Search results Close "},"external-_jQuery.fn_.html":{"id":"external-_jQuery.fn_.html","title":"External: jQuery.fn","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn External: jQuery.fn jQuery.fn The jQuery plugin namespace. Source: jquery-plugin.js, line 15 See: The jQuery Plugin Guide Methods &lt;static&gt; textHighlighter(options) Creates TextHighlighter instance and applies it to the given jQuery object. Parameters: Name Type Description options object Same as TextHighlighter options. Source: jquery-plugin.js, line 21 Returns: Type jQuery Example $('#sandbox').textHighlighter({ color: 'red' }); × Search results Close "},"IndependenciaHighlighter.html":{"id":"IndependenciaHighlighter.html","title":"Class: IndependenciaHighlighter","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn Class: IndependenciaHighlighter IndependenciaHighlighter new IndependenciaHighlighter(element [, options]) Creates an IndependenciaHighlighter instance for functionality that focuses for highlight independence. Parameters: Name Type Argument Description element HTMLElement DOM element to which highlighted will be applied. options object &lt;optional&gt; additional options. Properties Name Type Description color string highlight color. excludeNodes string Node types to exclude when calculating offsets and determining where to inject highlights. highlightedClass string class added to highlight, 'highlighted' by default. contextClass string class added to element to which highlighter is applied, 'highlighter-context' by default. onRemoveHighlight function function called before highlight is removed. Highlight is passed as param. Function should return true if highlight should be removed, or false - to prevent removal. onBeforeHighlight function function called before highlight is created. Range object is passed as param. Function should return true to continue processing, or false - to prevent highlighting. onAfterHighlight onAfterHighlightCallbackV2 function called after highlight is created. Array of created wrappers is passed as param. This should always return a set of descriptors. Source: highlighters/independencia.js, line 36 Methods deserializeHighlights(json) Deserializes the independent form of highlights. Parameters: Name Type Description json object JSON object with highlights definition. Source: highlighters/independencia.js, line 229 Throws: exception when can't parse JSON or JSON has invalid structure. Returns: array of deserialized highlights. Type Array doHighlight(keepRange) Highlights current range. Parameters: Name Type Description keepRange boolean Don't remove range after highlighting. Default: false. Source: highlighters/independencia.js, line 64 focusUsingId(id, descriptors) Focuses a highlight, bringing it forward in the case it is sitting behind another overlapping highlight, or a highlight it is nested inside. Parameters: Name Type Description id object The id of the highlight present in the class names of all elements in the DOM that represent the highlight. In order to utilise this functionality unique ids for highlights should be added to the class list in the highlight wrapper within the descriptors. You can do this in the onAfterHighlight callback when a highlight is first created. In the future it might be worth adding more flexiblity to allow for user-defined ways of storing ids to identify elements in the DOM. (e.g. choosing between class name or data attributes) descriptors string Optional serialised descriptors, useful in the case a highlight has no representation in the DOM where empty highlight wrapper nodes are removed to use less dom elements. Source: highlighters/independencia.js, line 325 getHighlights(params) Returns highlights from given container. Parameters: Name Type Description params Properties Name Type Argument Description container HTMLElement &lt;optional&gt; return highlights from this element. Default: the element the highlighter is applied to. andSelf boolean &lt;optional&gt; if set to true and container is a highlight itself, add container to returned results. Default: true. grouped boolean &lt;optional&gt; if set to true, highlights are grouped in logical groups of highlights added in the same moment. Each group is an object which has got array of highlights, 'toString' method and 'timestamp' property. Default: false. Source: highlighters/independencia.js, line 154 Returns: array of highlights. Type Array isHighlight(el) Returns true if element is a highlight. Parameters: Name Type Description el element to check. Source: highlighters/independencia.js, line 171 Returns: Type boolean normalizeHighlights() Normalizes highlights. Ensures text nodes within any given element node are merged together, elements with the same ID next to each other are merged together and highlights with the same ID next to each other are merged together. Source: highlighters/independencia.js, line 109 Returns: array of normalized highlights. Order and number of returned highlights may be different than input highlights. Type Array removeHighlights(element, id) Removes highlights from element. If element is a highlight itself, it is removed as well. If no element is given, all highlights are removed. Parameters: Name Type Description element HTMLElement element to remove highlights from id string The unique id of a highlight represented by a collection of elements. Source: highlighters/independencia.js, line 121 serializeHighlights() Serializes all highlights in the element the highlighter is applied to. Source: highlighters/independencia.js, line 180 Returns: stringified JSON with highlights definition Type string Type Definitions HighlightDescriptor Deselects a highlight, bringing any nested highlights in the list of descriptors forward. In order to utilise this functionality unique ids for highlights should be added to the class list in the highlight wrapper within the descriptors. You can do this in the onAfterHighlight callback when a highlight is first created. In the future it might be worth adding more flexiblity to allow for user-defined ways of storing ids to identify elements in the DOM. (e.g. choosing between class name or data attributes) Type: object Properties: Name Type Description id string serialisedDescriptor string Source: highlighters/independencia.js, line 355 × Search results Close "},"PrimitivoHighlighter.html":{"id":"PrimitivoHighlighter.html","title":"Class: PrimitivoHighlighter","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn Class: PrimitivoHighlighter PrimitivoHighlighter new PrimitivoHighlighter(element [, options]) Creates a PrimitivoHighlighter instance for functionality specific to the original implementation. Parameters: Name Type Argument Description element HTMLElement DOM element to which highlighted will be applied. options object &lt;optional&gt; additional options. Properties Name Type Description color string highlight color. highlightedClass string class added to highlight, 'highlighted' by default. contextClass string class added to element to which highlighter is applied, 'highlighter-context' by default. onRemoveHighlight function function called before highlight is removed. Highlight is passed as param. Function should return true if highlight should be removed, or false - to prevent removal. onBeforeHighlight function function called before highlight is created. Range object is passed as param. Function should return true to continue processing, or false - to prevent highlighting. onAfterHighlight onAfterHighlightCallbackV1 function called after highlight is created. Array of created wrappers is passed as param. Source: highlighters/primitivo.js, line 23 Methods deserializeHighlights(json) Deserializes highlights. Parameters: Name Type Description json object JSON object with highlights definition. Source: highlighters/primitivo.js, line 441 Throws: exception when can't parse JSON or JSON has invalid structure. Returns: array of deserialized highlights. Type Array doHighlight(keepRange) Highlights current range. Parameters: Name Type Description keepRange boolean Don't remove range after highlighting. Default: false. Source: highlighters/primitivo.js, line 271 flattenNestedHighlights(highlights) Flattens highlights structure. Note: this method changes input highlights - their order and number after calling this method may change. Parameters: Name Type Description highlights Array highlights to flatten. Source: highlighters/primitivo.js, line 151 getHighlights(params) Returns highlights from given container. Parameters: Name Type Description params Properties Name Type Argument Description container HTMLElement &lt;optional&gt; return highlights from this element. Default: the element the highlighter is applied to. andSelf boolean &lt;optional&gt; if set to true and container is a highlight itself, add container to returned results. Default: true. grouped boolean &lt;optional&gt; if set to true, highlights are grouped in logical groups of highlights added in the same moment. Each group is an object which has got array of highlights, 'toString' method and 'timestamp' property. Default: false. Source: highlighters/primitivo.js, line 360 Returns: array of highlights. Type Array highlightRange(range, wrapper) Highlights range. Wraps text of given range object in wrapper element. Parameters: Name Type Description range Range wrapper HTMLElement Source: highlighters/primitivo.js, line 53 Returns: array of created highlights. Type Array isHighlight(el) Returns true if element is a highlight. Parameters: Name Type Description el element to check. Source: highlighters/primitivo.js, line 377 Returns: Type boolean mergeSiblingHighlights(highlights) Merges sibling highlights and normalizes descendant text nodes. Note: this method changes input highlights - their order and number after calling this method may change. Parameters: Name Type Description highlights Source: highlighters/primitivo.js, line 237 normalizeHighlights(highlights) Normalizes highlights. Ensures that highlighting is done with use of the smallest possible number of wrapping HTML elements. Flattens highlights structure and merges sibling highlights. Normalizes text nodes within highlights. Parameters: Name Type Description highlights Array highlights to normalize. Source: highlighters/primitivo.js, line 126 Returns: array of normalized highlights. Order and number of returned highlights may be different than input highlights. Type Array removeHighlights( [element]) Removes highlights from element. If element is a highlight itself, it is removed as well. If no element is given, all highlights all removed. Parameters: Name Type Argument Description element HTMLElement &lt;optional&gt; element to remove highlights from Source: highlighters/primitivo.js, line 311 serializeHighlights() Serializes all highlights in the element the highlighter is applied to. Source: highlighters/primitivo.js, line 386 Returns: stringified JSON with highlights definition Type string × Search results Close "},"TextHighlighter.html":{"id":"TextHighlighter.html","title":"Class: TextHighlighter","body":" TextHighlighter Classes IndependenciaHighlighterPrimitivoHighlighterTextHighlighter Global arrayToLowercreateWrapperDATA_ATTRdomfindNodesAndOffsetsgetHighlightedTextForRangegetHighlightedTextRelativeToRootgroupHighlightshaveSameColorIGNORE_TAGSisClosestHighlightParentmergeSiblingTextNodesInDirectionnodesInBetweenrefineRangeBoundariesscaleFromTransformMatrixsortByDepthTIMESTAMP_ATTRunique Externals jQuery.fn Class: TextHighlighter TextHighlighter TextHighlighter that provides text highlighting functionality to dom elements. new TextHighlighter() Source: text-highlighter.js, line 66 Methods &lt;static&gt; createWrapper(options) Creates wrapper for highlights. TextHighlighter instance calls this method each time it needs to create highlights and pass options retrieved in constructor. Parameters: Name Type Description options object the same object as in TextHighlighter constructor. Source: text-highlighter.js, line 34 Returns: Type HTMLElement deserializeHighlights(json) Deserializes highlights. Parameters: Name Type Description json object JSON object with highlights definition. Source: text-highlighter.js, line 227 Throws: exception when can't parse JSON or JSON has invalid structure. Returns: array of deserialized highlights. Type Array destroy() Permanently disables highlighting. Unbinds events and remove context element class. Source: text-highlighter.js, line 112 find(text [, caseSensitive]) Finds and highlights given text. Parameters: Name Type Argument Description text string text to search for caseSensitive boolean &lt;optional&gt; if set to true, performs case sensitive search (default: true) Source: text-highlighter.js, line 237 focusUsingId(id, descriptors) Focuses a highlight, bringing it forward in the case it is sitting behind another overlapping highlight, or a highlight it is nested inside. This is only supported by independencia (v2-2019) and onwards. For older versions, this will simply do nothing. Parameters: Name Type Description id string The id of the highlight present in the class names of all elements in the DOM that represent the highlight. descriptors string Optional serialised descriptors, useful in the case a highlight has no representation in the DOM where empty highlight wrapper nodes are removed to use less dom elements. Source: text-highlighter.js, line 285 getColor() Returns highlighting color. Source: text-highlighter.js, line 164 Returns: Type string getHighlights(params) Returns highlights from given container. Parameters: Name Type Description params Properties Name Type Argument Description container HTMLElement &lt;optional&gt; return highlights from this element. Default: the element the highlighter is applied to. andSelf boolean &lt;optional&gt; if set to true and container is a highlight itself, add container to returned results. Default: true. grouped boolean &lt;optional&gt; if set to true, highlights are grouped in logical groups of highlights added in the same moment. Each group is an object which has got array of highlights, 'toString' method and 'timestamp' property. Default: false. Source: text-highlighter.js, line 193 Returns: array of highlights. Type Array highlightRange(range, wrapper) Highlights range. Wraps text of given range object in wrapper element. Parameters: Name Type Description range Range wrapper HTMLElement Source: text-highlighter.js, line 133 Returns: array of created highlights. Type Array isHighlight(el) Returns true if element is a highlight. All highlights have 'data-highlighted' attribute. Parameters: Name Type Description el element to check. Source: text-highlighter.js, line 204 Returns: Type boolean normalizeHighlights(highlights) Normalizes highlights. Ensure at least text nodes are normalized, carries out some flattening and nesting where necessary. Parameters: Name Type Description highlights Array highlights to normalize. Source: text-highlighter.js, line 146 Returns: array of normalized highlights. Order and number of returned highlights may be different than input highlights. Type Array removeHighlights(element, id) Removes highlights from element. If element is a highlight itself, it is removed as well. If no element is given, all highlights all removed. Parameters: Name Type Description element HTMLElement element to remove highlights from. if empty, the root element of the highlighter will be used. id string The unique id of a highlight represented by a collection of elements. Source: text-highlighter.js, line 176 serializeHighlights(id) Serializes all highlights in the element the highlighter is applied to. the id is not used in the initial version of the highlighter. Parameters: Name Type Description id string The unique identifier grouping a set of highlight elements together. Source: text-highlighter.js, line 216 Returns: stringified JSON with highlights definition Type string setColor(color) Sets highlighting color. Parameters: Name Type Description color string valid CSS color. Source: text-highlighter.js, line 155 Type Definitions HighlightDescriptor Deselects a highlight, bringing any nested highlights in the list of descriptors forward. This is only supported by independencia (v2-2019) and onwards. For older versions, this will simply do nothing. Type: object Properties: Name Type Description id string serialisedDescriptor string Source: text-highlighter.js, line 297 Class: TextHighlighter TextHighlighter new TextHighlighter(element [, options]) Creates TextHighlighter instance and binds to given DOM elements. Parameters: Name Type Argument Description element HTMLElement DOM element to which highlighted will be applied. options object &lt;optional&gt; additional options. Properties Name Type Description version string The version of the text highlighting functionality to use. There are two options: primitivo (v1-2014) is for the initial implementation using interdependent highlight locators. (Lots of issues for requirements beyond simple all or nothing highlights) independencia (v2-2019) is for an improved implementation focusing on making highlights independent from eachother and other element nodes within the context DOM object. v2 uses data attributes as the source of truth about the text range selected to create the original highlight. This allows us freedom to manipulate the DOM at will and handle overlapping highlights a lot better. color string highlight color. excludeNodes string Node types to exclude when calculating offsets and determining where to inject highlights. highlightedClass string class added to highlight, 'highlighted' by default. contextClass string class added to element to which highlighter is applied, 'highlighter-context' by default. onRemoveHighlight function function called before highlight is removed. Highlight is passed as param. Function should return true if highlight should be removed, or false - to prevent removal. onBeforeHighlight function function called before highlight is created. Range object is passed as param. Function should return true to continue processing, or false - to prevent highlighting. onAfterHighlight function function called after highlight is created. Array of created wrappers is passed as param. (The callback interface differs between versions, see specific highlighter classes for more info) Source: text-highlighter.js, line 38 Methods &lt;static&gt; createWrapper(options) Creates wrapper for highlights. TextHighlighter instance calls this method each time it needs to create highlights and pass options retrieved in constructor. Parameters: Name Type Description options object the same object as in TextHighlighter constructor. Source: text-highlighter.js, line 34 Returns: Type HTMLElement deserializeHighlights(json) Deserializes highlights. Parameters: Name Type Description json object JSON object with highlights definition. Source: text-highlighter.js, line 227 Throws: exception when can't parse JSON or JSON has invalid structure. Returns: array of deserialized highlights. Type Array destroy() Permanently disables highlighting. Unbinds events and remove context element class. Source: text-highlighter.js, line 112 find(text [, caseSensitive]) Finds and highlights given text. Parameters: Name Type Argument Description text string text to search for caseSensitive boolean &lt;optional&gt; if set to true, performs case sensitive search (default: true) Source: text-highlighter.js, line 237 focusUsingId(id, descriptors) Focuses a highlight, bringing it forward in the case it is sitting behind another overlapping highlight, or a highlight it is nested inside. This is only supported by independencia (v2-2019) and onwards. For older versions, this will simply do nothing. Parameters: Name Type Description id string The id of the highlight present in the class names of all elements in the DOM that represent the highlight. descriptors string Optional serialised descriptors, useful in the case a highlight has no representation in the DOM where empty highlight wrapper nodes are removed to use less dom elements. Source: text-highlighter.js, line 285 getColor() Returns highlighting color. Source: text-highlighter.js, line 164 Returns: Type string getHighlights(params) Returns highlights from given container. Parameters: Name Type Description params Properties Name Type Argument Description container HTMLElement &lt;optional&gt; return highlights from this element. Default: the element the highlighter is applied to. andSelf boolean &lt;optional&gt; if set to true and container is a highlight itself, add container to returned results. Default: true. grouped boolean &lt;optional&gt; if set to true, highlights are grouped in logical groups of highlights added in the same moment. Each group is an object which has got array of highlights, 'toString' method and 'timestamp' property. Default: false. Source: text-highlighter.js, line 193 Returns: array of highlights. Type Array highlightRange(range, wrapper) Highlights range. Wraps text of given range object in wrapper element. Parameters: Name Type Description range Range wrapper HTMLElement Source: text-highlighter.js, line 133 Returns: array of created highlights. Type Array isHighlight(el) Returns true if element is a highlight. All highlights have 'data-highlighted' attribute. Parameters: Name Type Description el element to check. Source: text-highlighter.js, line 204 Returns: Type boolean normalizeHighlights(highlights) Normalizes highlights. Ensure at least text nodes are normalized, carries out some flattening and nesting where necessary. Parameters: Name Type Description highlights Array highlights to normalize. Source: text-highlighter.js, line 146 Returns: array of normalized highlights. Order and number of returned highlights may be different than input highlights. Type Array removeHighlights(element, id) Removes highlights from element. If element is a highlight itself, it is removed as well. If no element is given, all highlights all removed. Parameters: Name Type Description element HTMLElement element to remove highlights from. if empty, the root element of the highlighter will be used. id string The unique id of a highlight represented by a collection of elements. Source: text-highlighter.js, line 176 serializeHighlights(id) Serializes all highlights in the element the highlighter is applied to. the id is not used in the initial version of the highlighter. Parameters: Name Type Description id string The unique identifier grouping a set of highlight elements together. Source: text-highlighter.js, line 216 Returns: stringified JSON with highlights definition Type string setColor(color) Sets highlighting color. Parameters: Name Type Description color string valid CSS color. Source: text-highlighter.js, line 155 Type Definitions HighlightDescriptor Deselects a highlight, bringing any nested highlights in the list of descriptors forward. This is only supported by independencia (v2-2019) and onwards. For older versions, this will simply do nothing. Type: object Properties: Name Type Description id string serialisedDescriptor string Source: text-highlighter.js, line 297 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
